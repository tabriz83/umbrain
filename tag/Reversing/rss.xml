<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>tabriz83.github.io/umbrain/</title>
   
   <link>http://tabriz83.github.io/umbrain/</link>
   <description>Memory Repository.</description>
   <language>en-uk</language>
   <managingEditor> taBRis</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>(完)우리집에 GDB 있는데... 메모리 보고갈래? (3)</title>
	  <link>/umbrain//gdb-memory-day3</link>
	  <author>taBRis</author>
	  <pubDate>2017-01-25T17:14:00+00:00</pubDate>
	  <guid>/umbrain//gdb-memory-day3</guid>
	  <description><![CDATA[
	     <p><strong>출처 : <a href="https://bpsecblog.wordpress.com/2016/05/20/gdb_memory_3/">(完)우리집에 GDB 있는데&hellip; 메모리 보고갈래? (3) - Hackerz on the Ship</a></strong></p>

<h2>Season 1. 우리집에 GDB있는데&hellip; 메모리 보고 갈래?</h2>

<p><br></p>

<h3>DAY #3. 이쯤 했으면 이제 그만 엔터치자</h3>

<p><br>
<img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-intro.jpg" alt="">
오늘부터 1일♡</p>

<hr>

<h4>1) Debugging  (IDA, GDB 사용)</h4>

<p>우리는 이미 tomato.c 소스가 있지만, 보통 소스는 잘 안주잖아여<br>
없다는 가정하에 디버깅을 해봅씨다.
<br></p>

<p><strong>• IDA (취약점 발견 !)</strong><br>
헥스레이라는 강력한 기능을 제공하는 디스어셈블러임다.</p>

<p>헥스레이는 바이너리를 디컴파일해서 원본 코드와 흡사한 소스를 떨궈줍니다.<br>
F5 단축키를 누르면 다음과 같이 디컴파일한 소스가 나옴미다.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-1.png" alt="">
<em>[그림 1] IDA의 HEX-RAY와 원본 소스 비교</em>
<br></p>

<p>헥스레이ㅋ 지리구요 오지구요<br>
유료 툴이지만 넘나 강력한 것.</p>

<p>전 보통 정적 분석할 때 아이다를 활용함다.<br>
(아이다로도 가능하지만, 전 동적으로 디버깅할 땐 보통 gdb를 활용함여)</p>

<p>IDA에서 8번째 라인을 봐주세요.</p>

<p>strcpy((char *) &amp;v4, argv[1]);의 코드에서<br>
buffer overflow 취약점이 나는 것을 손쉽게 확인할 수 있졈?</p>

<p>명령행인자 argv[1]를 v4 변수에 복사할 때 버퍼 크기를 검증하는 라인은 그 어디에도 없쟈나요.</p>

<p>변수 v4와 v5는 지역변수이기 때무네 스택 영역에 할당 되는데요.</p>

<p>length가 검증되지 않은 v4에 argv[1]의 값이 복사될 때,<br>
v4는 할당받은 공간 그 이상을 활용할 수 있게되거<br>
v5가 v4보다 높은 주소에 할당되어 있다면..?</p>

<p>v5에 원하는 값을 삽입할 수 있겠죠?<br>
(strcpy는 버퍼 오버플로우 취약점이 발생할 가능성이 농후하기 때문에 strcpy_s로 대체해 사용하길 권고하고 있슴다.)
<br></p>

<p><strong>• GDB ( 발견한 취약점으로 동적 분석 ㄱㄱ)</strong><br>
취약점이 발생한 strcpy를 call할 때 스택을 봐보겠슴다.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-2.png" alt="">
<em>[그림 2] main의 assembly code</em></p>

<p>strcpy 함수를 call하기 전에 스택에 매개인자들을 넣어줘여.
<br></p>

<p>0x0804851e에 breakpoint를 걸고, <strong>strcpy가 실행되기 전후의 스택</strong>을 보겠슴다.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-3.png" alt="">
<em>[그림 3] tomato 바이너리 실행</em>
<br></p>

<p>breakpoint 건 후, 명령행인자(argv[1])에 aaaaaaaa를 넘기고 실행해써요.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-4.png" alt="">
<em>[그림 4] strcpy 호출 전후</em>
<br></p>

<p>v4에 값이 잘 들어갔져?<br>
여기서 약간의 부연설명을 하도록 하겠습니다.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-5.png" alt="">
<em>[그림 5] strcpy 호출 전 assembly code 일부 발췌</em>
<br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">0x08048517 &lt;+49&gt;: lea eax,[esp+0x12]
0x0804851b &lt;+53&gt;: mov DWORD PTR [esp],eax
</code></pre></div>
<p>esp가 가리키는 값은 esp+0x12져?<br>
즉, v4의 값은 esp+0x12에 들어있는 거예여.</p>

<p>[그림 4]에서 esp가 가리키는 값, 즉 <strong>0xbfff692</strong>는 <strong>esp+0x12</strong>가 되겠졈?</p>

<p>다음은 [그림 2]의 main의 어셈코드에서 일부입니당.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-6.png" alt="">
<em>[그림 6] v5값을 비교하는 assembly code</em>
<br></p>

<p>esp+0x1c 값이 0x1 이면 system 함수가 실행되고,<br>
같지 않으면 0x0804854a &lt;+100&gt; :    mov  eax, 0x0으로 분기하네요.</p>

<p>잠시 [그림 1]의 IDA에서 main의 선언부를 보도록 하겠슴다.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-7.png" alt="">
<em>[그림 7] main 변수 선언</em>
<br></p>

<p>주석을 보면 v4는 [sp+12h]  [bp-Eh]<br>
v5는 [sp+1Ch] [bp-4h] 라고 보여지네요.</p>

<p>이 말인 즉슨, main의 stack frame의 esp, ebp를 기준으로,<br>
v4와 v5가 어디에 할당이 되어있는지 알 수 있어여.</p>

<p>assembly code를 보면 esp를 기준으로 v4와 v5에 값이 할당되고 있으니,<br>
esp를 기준으로 stack을 그려보도록 하겠습니다!</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-8.png" alt="">
<em>[그림 8] main의 스택</em>
<br></p>

<p>즉, v4의 값이 흘러넘치면~? v5에도 영향을 미칠 수 있겠죻ㅎㅎ<br>
확인해볼까요?</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-9.png" alt="">
<em>[그림 9] buffer overflow 발생, strcpy 직후 stack</em>
<br></p>

<p>[그림 6]의 assembly code에서 ESP+0X1C(v5) 값이 1이면<br>
system 함수를 호출하는 조건문 안으로 들어갈 수 있었기 때문에,<br>
이제 v5가 0x00000001이 되면 셸을 띄울 수 있겠죵?</p>

<hr>

<h4>2) EXPLOIT</h4>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-10.png" alt="">
<em>[그림 10] v5에 00000001 넣는 방법 (실패)</em>
<br></p>

<p>에휴.. 쉘이 안뜬거 보니 실패했네여&hellip;<br>
왜 그런가 한번 gdb로 봐보댜구요.
<br></p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-11.png" alt="">
<em>[그림 11] 왜 때문에 실패?</em>
<br></p>

<p>내가 원하는건 이거자나여..</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-12.png" alt="">
<em>[그림 12] 이걸 원하는건데..ㅠ 왜 때무네 [그림 11]처럼 되는거지ㅠ</em>
<br></p>

<p>우리는 문자열 00000001이 아닌 버퍼에 0x00000001을 넣고 싶은거자나요.<br>
근데 문자열로 들어가버려서 fail..★</p>

<p>hex 값을 입력하기 위해서는 평소 command line에서 입력하듯이 할 수 없어여.<br>
그래서 python이나 perl과 같은 언어의 힘을 빌려야함당.</p>

<p>python을 사용해서 해보도록 할게요!</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-13.png" alt="">
<em>[그림 13] python으로 command line에서 출력하기</em>
<br></p>

<p>python에서 -c 옵션을 활용하면 command 라인에서 출력을 할 수 있어요.</p>

<p>python으로는 hex 값을 표현할 수 있기 때문에,<br>
이를 활용해 출력값을 in09 파일에 저장한 것이 보이졈?<br>
(in09 파일에서 보이는  <sup>@<sup>@<sup>@<sup>A는</sup></sup></sup></sup> 헥스값으로 0x00000001임다)</p>

<p>그리고 쉘 프롬프트에서 사용하는 <strong>`(백틱)</strong>에 대해<br>
잠깐 설명하고 넘어가도록 하겠슴미다.</p>

<p>우리는 명령행인자로 ‘in09 파일의 출력 값’을 넘겨야해요..ㅠ<br>
이럴 때 활용할 수 있는 것이 바로 `(백틱)인데요.<br>
쉘 커맨드의 출력 값을 리턴해주는 용도로 활용됩니다.  </p>

<p>뭔 말이냐면여..</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-14.png" alt="">
<em>[그림 14] 백틱의 활용 예</em>
<br></p>

<p>whoami라는 명령어의 출력 값은 in09임다.</p>

<p>이 shell command를 `으로 감싸서, tomato 바이너리의 명령행인자로 넘기면<br>
whoami 명령어의 출력 값이 입력 값으로 넘어가고 있어요(arr을 보세요)!  </p>

<p>어떻게 활용하는지 감이 오시냐염?</p>

<hr>

<h4>3) FINAL</h4>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-15.png" alt="">
<em>[그림 15] exploit 성공! (1)</em></p>

<p>셸이 뿅★<br>
출력 값을 in09 파일에 저장했었졈? 그걸 활용해도 되고여,
<br></p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-16.png" alt="">
<em>[그림 16] exploit 성공! (2)</em></p>

<p>바로 활용해도 됨다.<br>
오예!
<br></p>

<hr>

<p>드디어 gdb 시리즈가 끝났슘다.</p>

<p>뉴비들의 교과서를 쓰고 싶었는데 아쉬움이 남네요ㅠ<br>
무엇보다 이제 이런 되도 않는 컨셉은 버려야겠어요ㅋ..</p>

<p>감사함미다 뿅!</p>

<p>-written by in09</p>

	  ]]></description>
	</item>

	<item>
	  <title>우리집에 GDB 있는데... 메모리 보고갈래? (2)</title>
	  <link>/umbrain//gdb-memory-day2</link>
	  <author>taBRis</author>
	  <pubDate>2017-01-24T01:56:00+00:00</pubDate>
	  <guid>/umbrain//gdb-memory-day2</guid>
	  <description><![CDATA[
	     <p><strong>출처 : <a href="https://bpsecblog.wordpress.com/2016/04/04/gdb_memory_2/">우리집에 GDB 있는데&hellip; 메모리 보고갈래? (2) - Hackerz on the Ship</a></strong></p>

<h2>Season 1. 우리집에 GDB있는데&hellip; 메모리 보고 갈래?</h2>

<p><br></p>

<h3>DAY #2. 애프터 신청 (<del>너</del> gdb 사용법, 갖고싶다.. 너란 stack)</h3>

<p><br>
<img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-intro.png" alt="*인트로*">
<br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">//tomato.c

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;&#39;

void func2() {
    puts(&quot;func2()&quot;);
}

void sum(int a, int b) {
    printf(&quot;sum : %d\n&quot;, a+b);
    func2();
}

int main(int argc, char *argv[]) {

    int num=0;
    char arr[10];

    sum(1,2);
    strcpy(arr,argv[1]);
    printf(&quot;arr: %s\n&quot;, arr);
    if(num==1){
        system(&quot;/bin/sh&quot;);
    }
    return 0;
}
</code></pre></div>
<p><br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">in09@ubuntu:~/bpsecblog/day2$ gcc -fno-stack-protector -o tomato tomato.c
</code></pre></div>
<blockquote>
<p><strong>-fno-stack-protector 옵션을 포함하는 이유</strong><br>
gcc가 스택을 보호하기 위해 ‘canary’라는 것을 삽입해요.<br>
함수 내에서 사용하는 스택 프레임과 return address 사이에<br>
canary를 넣어염.</p>

<p>Buffer Overflow가 발생해 canary를 덮었을 때,<br>
이를 감지하고 프로그램을 강제 종료 해 버린답니당.</p>

<p>이를 <strong>SSP</strong>(Stack Smashing Protection)이라고 해요.</p>

<p>여기에선 오버플로우가 발생해도 프로그램이 강제 종료되지 않도록,<br>
<strong>–fno-stack-protector</strong> 옵션을 사용해 <strong>보호기법을 해제</strong>한겁니답.</p>

<p>반대로 모든 프로시져에 이 <strong>보호기법을 적용</strong>하기 위해서는,<br>
<strong>-fstack-protector-all</strong> 옵션을 사용하세염</p>

<p><a href="https://bpsecblog.wordpress.com/2016/03/26/watermelon-feat-%ec%b6%9c%ec%a0%9c%ec%9e%90-in09/">[Go to Watermelon]</a><br>
(CodeGate2016 watermelon writeup에서<br>
canary에 대한 자세한 내용이 있으니 참고하셔도 좋습니당!)</p>
</blockquote>

<p><br></p>

<p>이제 GDB를 활용해보도록 할까욤?</p>

<hr>

<h4>Ch 1. <del>너</del>  gdb 사용법</h4>

<p><br></p>

<p><img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-intro2.png" alt=""></p>

<blockquote>
<p>하라니까 하겠는데.<br>
근데 GDB를 왜 써야되는데?</p>
</blockquote>

<p><br></p>

<p>지..진정하세요.</p>

<p>gdb는 오픈소스로 공개되어있는 무료 디버거랍니다.<br>
아 디버거가 뭐냐거여?</p>

<p>님들 해답지보고 공부할 때,<br>
왜 이러저러하게 이 답이 도출이 되는지 보잖아요.</p>

<p>디버거도 그런검미다.<br>
코드에서 이 라인을 실행할 때, 어떤 값이 어떤 메모리 주소에 올라가고<br>
그 과정을 보여주는거져.</p>

<p>컴퓨터 계의 X-RAY랄까?  </p>

<p>gdb를 쓰면 물론 콘솔 기반이라.. 빡치긴 해여..<br>
ida 봐봐여… 아름답잖아요..</p>

<p>하지만 ELF 파일과 같은 Linux 기반의 실행파일을<br>
동적으로 따라가며 분석할 때 gdb 참 쓸만하져.</p>

<p>그래서 이거 씀미다.</p>

<p>긍까 쫄지말고 긔긔.</p>

<hr>

<p>GDB로 tomato를 실행시켜봅시당.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">in09@ubuntu:~/bpsecblog/day2$ gdb ./tomato
</code></pre></div>
<p>이건 그냥 gdb로 tomato에 붙은 것에 불과해여.<br>
아직 우리의 토마토는 실행되지 않았담미다.</p>

<p>일단 gdb 켜봤으면 뭐.. 어셈도 한번 봐주고,<br>
tomato를 실행하기 전에 이것 저것 설정도 해줘야쥬?</p>

<p>일단 보기 편하게 어셈 코드를 intel 형식으로 설정해<br>
main을 출력해 보겠습니답.ㅎㅎ</p>

<blockquote>
<p><strong>set disassembly-flavor [명령어 형식]</strong><br>
어셈블리 코드 문법을 설정하는 명령어.<br>
x86에서 Intel과 at&amp;t 둘 중 하나를 골라 쓰면 됨.<br>
[명령어 형식의 예] : intel, att</p>

<p><strong>disas [함수이름]</strong><br>
함수의 어셈블리 코드를 보는 명령어.</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) set disassembly-flavor intel  
(gdb) disas main  
      Dump of assembler code for function main:  
         0x080484e6 &lt;+0&gt;: push   ebp  
         0x080484e7 &lt;+1&gt;: mov    ebp,esp  
         0x080484e9 &lt;+3&gt;: and    esp,0xfffffff0  
         0x080484ec &lt;+6&gt;: sub    esp,0x20  
         0x080484ef &lt;+9&gt;: mov    DWORD PTR [esp+0x1c],0x0  
         0x080484f7 &lt;+17&gt;: mov    DWORD PTR [esp+0x4],0x2  
         0x080484ff &lt;+25&gt;: mov    DWORD PTR [esp],0x1  
         0x08048506 &lt;+32&gt;: call   0x80484c1 &lt;sum&gt;  
         0x0804850b &lt;+37&gt;: mov    eax,DWORD PTR [ebp+0xc]  
         0x0804850e &lt;+40&gt;: add    eax,0x4  
         0x08048511 &lt;+43&gt;: mov    eax,DWORD PTR [eax]  
         0x08048513 &lt;+45&gt;: mov    DWORD PTR [esp+0x4],eax  
         0x08048517 &lt;+49&gt;: lea    eax,[esp+0x12]  
         0x0804851b &lt;+53&gt;: mov    DWORD PTR [esp],eax  
         0x0804851e &lt;+56&gt;: call   0x8048360 &lt;strcpy@plt&gt;  
         0x08048523 &lt;+61&gt;: lea    eax,[esp+0x12]  
         0x08048527 &lt;+65&gt;: mov    DWORD PTR [esp+0x4],eax  
         0x0804852b &lt;+69&gt;: mov    DWORD PTR [esp],0x8048602  
         0x08048532 &lt;+76&gt;: call   0x8048350 &lt;printf@plt&gt;  
         0x08048537 &lt;+81&gt;: cmp    DWORD PTR [esp+0x1c],0x1  
         0x0804853c &lt;+86&gt;: jne    0x804854a &lt;main+100&gt;  
         0x0804853e &lt;+88&gt;: mov    DWORD PTR [esp],0x804860b  
         0x08048545 &lt;+95&gt;: call   0x8048380 &lt;system@plt&gt;  
         0x0804854a &lt;+100&gt;: mov    eax,0x0  
         0x0804854f &lt;+105&gt;: leave  
         0x08048550 &lt;+106&gt;: ret  
      End of assembler dump.
</code></pre></div>
<p>메인이 이렇게 구성되어 있네요.</p>

<p>main에 breakpoint를 걸고 한번 실행해 볼까요?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">0x080484e6 &lt;+0&gt;: push   ebp
</code></pre></div>
<p>이게 main의 시작이잖아요?</p>

<blockquote>
<p><strong>b *[메모리주소]</strong><br>
breakpoint를 거는 명령.</p>

<p><u>[메모리 주소]</u>나 <u>[함수의 이름]</u> 혹은,<br>
이를 기준으로 한 <u>[offset &lt;+0&gt;]</u>으로<br>
breakpoint를 걸어도 됩니당.</p>

<p>* breakpoint를 걸 땐, 주소 앞에 *를 붙이세요!</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) b *main
Breakpoint 1 at 0x80484e6
(gdb) b *0x080484e6
Note: breakpoint 1 also set at pc 0x80484e6
Breakpoint 2 at 0x80484e6
(gdb) b *main+0
Note: breakpoints 1 and 2 also set at pc 0x80484e
Breakpoint 3 at 0x80484e6
</code></pre></div>
<p>모두 똑같은 곳에 breakpoint가 걸렸죠?
<br></p>

<p><strong>breakpoint</strong> 정보를 확인해볼게용</p>

<blockquote>
<p><strong>info b</strong><br>
breakpoint 정보를 열람할 수 있는 명령어</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) info b
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x080484e6 &lt;main&gt;
2       breakpoint     keep y   0x080484e6 &lt;main&gt;
3       breakpoint     keep y   0x080484e6 &lt;main&gt;
</code></pre></div>
<p><br></p>

<p><strong>Breakpoint</strong>가 중복되니 삭제해보도록 하겠습니당</p>

<blockquote>
<p><strong>d (breakpoint 번호)</strong><br>
breakpoint를 삭제 할 수 있는 명령어</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) d 2
(gdb) d 3
(gdb) info b
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x080484e6 &lt;main&gt;
</code></pre></div>
<p><br></p>

<p>이제 <strong>프로그램을 실행</strong>해볼게요!<br>
이제야 비로소.. 아 토마토 다 뿔었겠네. ㅡㅡ</p>

<blockquote>
<p><strong>run [매개변수]</strong><br>
gdb 내부에서 프로그램 실행</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) run aaaaaaaaaa
Starting program: /home/in09/bpsecblog/day2/tomato aaaaaaaaaa
Breakpoint 1, 0x080484e6 in main ()
(gdb)
</code></pre></div>
<p>헌데 명령행 인자로 main의 매개변수에 값이 넘어가죠?<br>
그래서 “aaaaaaaaa” 스트링을 넘겨준 거예요.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">in09@ubuntu:~/bpsecblog/day2$ ./tomato aaaaaaaaaa
 sum : 3
 func2()
 arr: aaaaaaaaaa 
</code></pre></div>
<p>터미널에서 위와 같이 실행하는 것과 동일한거죠!
<br></p>

<p>현재 우리 실행 흐름이 어디에 있는지 EIP를 확인해볼게요! Main에 멈춰있어야겠죠?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">gdb) disas main
Dump of assembler code for function main:
=&gt; 0x080484e6 &lt;+0&gt;: push   ebp
   0x080484e7 &lt;+1&gt;: mov    ebp,esp
   0x080484e9 &lt;+3&gt;: and    esp,0xfffffff
   0x080484ec &lt;+6&gt;: sub    esp,0x20
</code></pre></div>
<p>=&gt; 화살표가 보이졍?<br>
아주 잘 멈춰져있네요.<br>
인스트럭션을 한줄 한줄 실행해볼게염.</p>

<blockquote>
<p><strong>ni</strong>
다음 인스트럭션 실행</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) ni
0x080484e7 in main ()
(gdb) ni
0x080484e9 in main ()
(gdb) disas main
Dump of assembler code for function main:
   0x080484e6 &lt;+0&gt;: push   ebp
   0x080484e7 &lt;+1&gt;: mov    ebp,esp
=&gt; 0x080484e9 &lt;+3&gt;: and    esp,0xfffffff0
   0x080484ec &lt;+6&gt;: sub    esp,0x20
</code></pre></div>
<p>현재 EIP가 멈춰져있는 곳 이 전의 밑줄 친 <u>인스트럭션</u>을 보면,<br>
esp 값을 ebp 값에 저장하고 있죠?</p>

<p>esp, ebp는 스택과 관련한 레지스터잖아요!<br>
그 메모리에 어떤 값이 담겨있는지 gdb로 확인해보도록 하게씀미당.
<br></p>

<p>그 전에 메모리 출력 방식에 대해 정리하고 가도록 할게요.<br>
<strong>몇 바이트</strong>만큼 그리고 <strong>몇 진법</strong>으로 출력할 것인지 정해 옵션을 주어 출력해 주면 됨미다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/b 0x080484e6
0x80484e6 &lt;main&gt;: 0x55
(gdb) x/h 0x080484e6
0x80484e6 &lt;main&gt;: 0x8955
(gdb) x/w 0x080484e6
0x80484e6 &lt;main&gt;: 0x83e58955
</code></pre></div>
<p>해당 메모리 주소의 값을 각각 1바이트, 2바이트, 4바이트만큼 출력해주었습니다.</p>

<p><br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/x 0x080484e6
0x80484e6 &lt;main&gt;: 0x83e58955
(gdb) x/u 0x080484e6
0x80484e6 &lt;main&gt;: 2212858197
</code></pre></div>
<p>해당 메모리 주소 값을 16진수, 10진수로 출력해주었습니다.<br>
보통 이렇게들 씁니당.<br>
(진법 옵션이든 바이트 옵션이든 생략되면 이전 옵션으로 실행해줍니다.)</p>

<p><br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/wx 0x080484e6
0x80484e6 &lt;main&gt;: 0x83e58955
(gdb) x/4b 0x080484e6
0x80484e6 &lt;main&gt;: 0x55 0x89 0xe5 0x83
</code></pre></div>
<p>헙.. 근데 순서가 조금 이상하죠?
4바이트 출력한 것과 1바이트씩 4개를 출력한 것과 순서가 반대예요!
이것은 <strong>바이트 오더링</strong> 개념에 대해 이해를 해야 하는데요.</p>

<blockquote>
<p><strong>Byte Ordering [Big Endian / Little Endian]</strong>  </p>

<p>Intel CPU는 바이트를 배열할 때 <u>거꾸로 쓰게</u> 됩니다.<br>
예를 들어 0x12345678을 저장한다고 하면, <strong>0x78563412</strong>와 같이 거꾸로 저장하게 됩니다.<br>
이를 <strong><u>Little Endian</u></strong>이라 지칭합니다.</p>

<p>반면, gdb는 디버깅 시에 보기 편하게 하기 위해서<br>
Big Endian 형식으로 <strong>0x12345678</strong>와 같이 출력해주기 때문에,<br>
1바이트씩 출력할 때와 4바이트로 출력할 때 달리 보이는 거예요.</p>

<p>• 참고로 네트워크 상에서는 <u><strong>Big Endian</strong></u> 형식의 바이트 오더링을 사용합니다.</p>
</blockquote>

<p><br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/4wx $esp
0xbffff6b8: 0x00000000 0xb7e2fa83 0x00000002 0xbffff754
</code></pre></div>
<p>특정 레지스터를 기준으로 메모리 값을 보고 싶으면,<br>
$register_name으로 출력해볼 수 있습니당.
<br></p>

<p>다음은 ebp와 esp를 출력하는 것이고,<br>
info reg 혹은 i r은 레지스터 정보를 출력하는 명령입니답.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/wx $ebp
0xbffff6b8: 0x00000000
(gdb) x/wx $esp
0xbffff6b8: 0x00000000
(gdb) info reg $ebp
ebp            0xbffff6b8 0xbffff6b8
(gdb) i r $ebp $esp
ebp            0xbffff6b8 0xbffff6b8
esp            0xbffff6b8 0xbffff6b8
(gdb) i r
eax            0x2 2
ecx            0x7ce225d5 2095195605
edx            0xbffff6e4 -1073744156
ebx            0xb7fc0000 -1208221696
esp            0xbffff6b8 0xbffff6b8
ebp            0xbffff6b8 0xbffff6b8
esi            0x0 0
edi            0x0 0
eip            0x8048480 0x8048480 &lt;main+3&gt;
eflags         0x246 [ PF ZF IF ]
cs             0x73 115
ss             0x7b 123
ds             0x7b 123
es             0x7b 123
fs             0x0 0
gs             0x33 51
</code></pre></div>
<p>자.. 이제 gdb 사용법은 거진 다 익힌 것 같아요.</p>

<p>이제 우리 좀 더 알아가볼까요..?ㅎㅎ</p>

<hr>

<h4>Ch 2. 갖고싶다.. 너란 stack..</h4>

<p><br></p>

<p><img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-1.png" alt="">
<em>[그림 1] Stack과 관련한 레지스터</em>
<br></p>

<p>• 현재 EIP 상황(main 2줄 실행)  </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">  0x080484e6 &lt;+0&gt;: push   ebp
  0x080484e7 &lt;+1&gt;: mov    ebp,esp
=&gt;0x080484e9 &lt;+3&gt;: and    esp,0xfffffff0
  0x080484ec &lt;+6&gt;: sub    esp,0x20
  0x080484ef &lt;+9&gt;: mov    DWORD PTR [esp+0x1c],0x0
  0x080484f7 &lt;+17&gt;: mov    DWORD PTR [esp+0x4],0x2
  0x080484ff &lt;+25&gt;: mov    DWORD PTR [esp],0x1
  0x08048506 &lt;+32&gt;: call   0x80484c1 &lt;sum&gt;
</code></pre></div>
<p><br></p>

<h5>1. 스택의 시작</h5>

<blockquote>
<p><em>PUSH EBP</em><br>
<em>MOV EBP, ESP</em></p>
</blockquote>

<p>단 두 줄의 인스트럭션만 실행이 되었기 때문에 별 건 없져?<br>
하지만 저 단 두 줄의 어셈이 의미하는 바는 상당합니다.<br>
바로 <mark>&lsquo;스택(프레임)이 생성&rsquo;</mark>이 된다는 것이죠.</p>

<p>저 두 줄의 의미는,  </p>

<blockquote>
<p><mark>&#39;함수가 실행이 될 때, 그 이전의 ebp(sfp)를 스택에 push하고<br>
현재 esp를 ebp에 저장하라.(새로운 ebp 생성!)&rsquo;</mark></p>
</blockquote>

<p>이라는 뜻임미당.
<br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">0x08048506 &lt;+32&gt;: call   0x80484c1 &lt;sum&gt;
</code></pre></div>
<p>여기에 breakpoint를 걸고 실행시킨 후 스택의 상황을 보겠습니답.<br>
breakpoint까지 한 번에 뛰려면 c 명령을 사용하면 됩니당.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) b *main+32
Breakpoint 2 at 0x8048506
(gdb) c
Continuing.
Breakpoint 2, 0x08048506 in main ()
(gdb) disas main
Dump of assembler code for function main:
  0x080484e6 &lt;+0&gt;: push   ebp
  0x080484e7 &lt;+1&gt;: mov    ebp,esp
  0x080484e9 &lt;+3&gt;: and    esp,0xfffffff0 
  0x080484ec &lt;+6&gt;: sub    esp,0x20
  0x080484ef &lt;+9&gt;: mov    DWORD PTR [esp+0x1c],0x0
  0x080484f7 &lt;+17&gt;: mov    DWORD PTR [esp+0x4],0x2
  0x080484ff &lt;+25&gt;: mov    DWORD PTR [esp],0x1
=&gt;0x08048506 &lt;+32&gt;: call   0x80484c1 &lt;sum&gt;
</code></pre></div>
<p>원하는 곳에 멈춰잇쪄?</p>

<p>• sum이 call되기 전 상황
<img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-2.png" alt="">
<em>[그림 2] sum이 call되기 전 상황</em>
<br></p>

<p>그리고 sum 함수 안으로 들어가보도록 하겠습니다.<br>
call을 할 때는, 다음 인스트럭션의 주소를 스택에 쌓고 가죠?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">0x08048506 &lt;+32&gt;: call   0x80484c1 &lt;sum&gt;
0x0804850b &lt;+37&gt;: mov    eax,DWORD PTR [ebp+0xc]
</code></pre></div>
<p>call sum에 breakpoint를 걸고 (0x080484c1)<br>
sum 안으로 들어가면,</p>

<p><strong>스택에 ESP(0x00000001)위에 0x0804850b가 쌓였을 거예여.</strong></p>

<p>확인해볼까욤?</p>

<p>• sum이 call된 후의 상황
<img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-3.png" alt="">
<em>[그림 3] sum이 call된 후의 상황</em>
<br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/10i $eip
=&gt; 0x80484c1 &lt;sum&gt;: push   ebp
   0x80484c2 &lt;sum+1&gt;: mov    ebp,esp
   0x80484c4 &lt;sum+3&gt;: sub    esp,0x18
   0x80484c7 &lt;sum+6&gt;: mov    eax,DWORD PTR [ebp+0xc]
...생략...
(gdb) ni
</code></pre></div>
<p>sum 함수 안으로 들어왔쪄?</p>

<p>오 역시나..</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Push ebp
mov  ebp, esp
</code></pre></div>
<p>하고 있어욤.</p>

<p><em>Push ebp</em>를 실행하면,<br>
그 이전 스택 프레임(main)의 ebp가<br>
sum의 스택 프레임에 push될거예여.</p>

<p>즉, main의 ebp 0xbffff758가 esp에 들어가겠쬬?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) ni
(gdb) x/wx $esp
0xbffff728: 0xbffff758
</code></pre></div>
<p>오오… 마쟈마쟈ㅠㅠ</p>

<p>그리고 <code class="prettyprint">mov ebp, esp</code>를 하면,<br>
현재 esp를 sum stack frame의 바닥</p>

<p>즉, sum의 ebp로 만들어주겠져?</p>

<p>그러므로 sum의 ebp에는 main의 ebp가 있게되겠져.</p>

<p><img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-4.png" alt="">
<em>[그림 4] sum 함수에 들어갔을 때 ebp의 변화</em>
<br></p>

<p>이제 새로운 sum의 스택 프레임이 생성되었습니다!!<br>
확인해볼까요?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/15wx $ebp
0xbffff728: 0xbffff758 0x0804850b 0x00000001 0x00000002
0xbffff738: 0xbffff800 0xb7e4942d 0xb7fc03c4 0xb7fff000
0xbffff748: 0x0804856b 0x00000000 0x08048560 0x00000000
0xbffff758: 0x00000000 0xb7e2fa83 0x00000002
</code></pre></div>
<blockquote>
<p>0xbffff758 : <strong>sum의 stack frame</strong></p>

<blockquote>
<p>0x0804850b 0x00000001 0x00000002<br>
0xbffff800 0xb7e4942d 0xb7fc03c4 0xb7fff000<br>
0x0804856b 0x00000000 0x08048560 0x00000000<br>
0x00000000 : <strong>main의 stack frame</strong></p>
</blockquote>
</blockquote>

<p>이제 새로운 sum의 스택 프레임이 생성되었습니다!!<br>
(현재 tomato.c에서 sum(1,2)라인이 실행 중이겠져?)
<br></p>

<p>상단의 스택을 첫줄만 간추려보도록 하겠습니당.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">0xbffff728: 0xbffff758 0x0804850b 0x00000001 0x00000002
</code></pre></div>
<p><img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-5.png" alt="">
<em>[그림 5] ebp를 기준으로 보쎄용</em>
<br></p>

<p>보이심까?</p>

<blockquote>
<p><mark>새로운 스택 프레임의 ebp를 기준으로<br>
<strong>return address</strong>는 <strong>ebp-4</strong>,<br>
<u>매개인자</u>는 <u>ebp-8</u>, ebp -12와 같이 들어가게 됩니다!</mark></p>
</blockquote>

<p>꼭 기억하세욤~
<br></p>

<blockquote>
<p><strong>c</strong><br>
프로그램이 gdb로 run된 이후에<br>
다음 중단점까지 실행하는 명령어</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/10i $eip
=&gt; 0x80484c4 &lt;sum+3&gt;: sub    esp,0x18
   0x80484c7 &lt;sum+6&gt;: mov    eax,DWORD PTR [ebp+0xc]
   0x80484ca &lt;sum+9&gt;: mov    edx,DWORD PTR [ebp+0x8]
   0x80484cd &lt;sum+12&gt;: add    eax,edx
   0x80484cf &lt;sum+14&gt;: mov    DWORD PTR [esp+0x4],eax
   0x80484d3 &lt;sum+18&gt;: mov    DWORD PTR [esp],0x80485f8
   0x80484da &lt;sum+25&gt;: call   0x8048350 &lt;printf@plt&gt;
   0x80484df &lt;sum+30&gt;: call   0x80484ad &lt;func2&gt;
   0x80484e4 &lt;sum+35&gt;: leave 
   0x80484e5 &lt;sum+36&gt;: ret
(gdb) b *0x080484ad
Breakpoint 4 at 0x80484ad
(gdb) c
Continuing.
sum : 3
Breakpoint 4, 0x080484ad in func2 ()
(gdb) x/i $eip
=&gt; 0x80484ad &lt;func2&gt;: push   ebp
(gdb) ni
0x080484ae in func2 ()
(gdb) x/i $eip
=&gt; 0x80484ae &lt;func2+1&gt;: mov    ebp,esp
(gdb) ni
   0x080484b0 in func2 ()
</code></pre></div>
<p>자.. 또 sum 안에서 func2를 호출했어요.</p>

<p>그럼 아마 스택의 모습은<br>
<strong>| func2 stack frame | sum stack frame | main stack frame|</strong> 과 같이 되겠져?</p>

<p>확인해볼게염.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/23wx $ebp
0xbffff708: 0xbffff728 0x080484e4 0x080485f8 0x00000003
0xbffff718: 0x00000001 0x0804831d 0xbffff914 0x0000002f
0xbffff728: 0xbffff758 0x0804850b 0x00000001 0x00000002
0xbffff738: 0xbffff800 0xb7e4942d 0xb7fc03c4 0xb7fff000
0xbffff748: 0x0804856b 0x00000000 0x08048560 0x00000000
0xbffff758: 0x00000000 0xb7e2fa83 0x00000002 
</code></pre></div>
<blockquote>
<p>0xbffff728 : <strong>func2의 stack frame</strong>  </p>

<blockquote>
<p>0x080484e4 0x080485f8 0x00000003<br>
0x00000001 0x0804831d 0xbffff914 0x0000002f<br>
0xbffff758 : <strong>sum의 stack frame</strong>  </p>

<blockquote>
<p>0x0804850b 0x00000001 0x00000002<br>
0xbffff800 0xb7e4942d 0xb7fc03c4 0xb7fff000<br>
0x0804856b 0x00000000 0x08048560 0x00000000<br>
0x00000000 0xb7e2fa83 0x00000002 : <strong>main의 stack frame</strong></p>
</blockquote>
</blockquote>
</blockquote>

<p>시작이 있으면 끝이 있겠져?<br>
스택의 프레임이 시작되는,<br>
<code class="prettyprint">Push ebp</code><br>
<code class="prettyprint">mov ebp, esp</code>를 자세히 살펴보았으니,</p>

<p>스택 프레임의 끝<br>
<strong>Leave</strong>, <strong>Ret</strong>을 살펴보도록 하겠습니다.</p>

<p><br></p>

<h5>2. stack의 끝</h5>

<blockquote>
<p><strong>Leave</strong><br>
<strong>Ret</strong></p>
</blockquote>

<p><strong>• 현재 EIP 상황</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) disas func2
Dump of assembler code for function func2:
   0x080484ad &lt;+0&gt;: push   ebp
   0x080484ae &lt;+1&gt;: mov    ebp,esp
   0x080484b0 &lt;+3&gt;: sub    esp,0x18
   0x080484b3 &lt;+6&gt;: mov    DWORD PTR [esp],0x80485f0
   0x080484ba &lt;+13&gt;: call   0x8048370 &lt;puts@plt&gt;
=&gt; 0x080484bf &lt;+18&gt;: leave 
   0x080484c0 &lt;+19&gt;: ret
</code></pre></div>
<p><br></p>

<p><strong>• <u>leave 실행 전의 스택 상황</u></strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/28wx $esp
0xbffff6f0: 0x080485f0 0x080485f8 0xbffff714 0xb7e63280
0xbffff700: 0x00000003 0xb7fff938 0xbffff728 0x080484e4
0xbffff710: 0x080485f8 0x00000003 0x00000001 0x0804831d
0xbffff720: 0xbffff914 0x0000002f 0xbffff758 0x0804850b
0xbffff730: 0x00000001 0x00000002 0xbffff800 0xb7e4942d
0xbffff740: 0xb7fc03c4 0xb7fff000 0x0804856b 0x00000000
0xbffff750: 0x08048560 0x00000000 0x00000000 0xb7e2fa83
(gdb) i r $ebp $esp
ebp            0xbffff708 0xbffff708
esp            0xbffff6f0 0xbffff6f0
</code></pre></div>
<blockquote>
<p>0x080485f0 0x080485f8 0xbffff714 0xb7e63280<br>
0x00000003 0xb7fff938 0xbffff728 : <strong>func2의 stack frame</strong>  </p>

<blockquote>
<p>0x080484e4<br>
0x080485f8 0x00000003 0x00000001 0x0804831d<br>
0xbffff914 0x0000002f 0xbffff758 : <strong>sum의 stack frame</strong>  </p>

<blockquote>
<p>0x0804850b<br>
0x00000001 0x00000002 0xbffff800 0xb7e4942d<br>
0xb7fc03c4 0xb7fff000 0x0804856b 0x00000000<br>
0x08048560 0x00000000 0x00000000 : <strong>main의 stack frame</strong></p>
</blockquote>
</blockquote>
</blockquote>

<p><br></p>

<p><strong>• leave 실행 후의 스택 상황</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) ni
0x080484c0 in func2 ()
(gdb) x/20wx $esp
0xbffff70c: 0x080484e4 0x080485f8 0x00000003 0x00000001
0xbffff71c: 0x0804831d 0xbffff914 0x0000002f 0xbffff758
0xbffff72c: 0x0804850b 0x00000001 0x00000002 0xbffff800
0xbffff73c: 0xb7e4942d 0xb7fc03c4 0xb7fff000 0x0804856b
0xbffff74c: 0x00000000 0x08048560 0x00000000 0x00000000
(gdb) i r $ebp $esp
ebp            0xbffff728 0xbffff728
esp            0xbffff70c 0xbffff70c
</code></pre></div>
<blockquote>
<p>0x080484e4 0x080485f8 0x00000003 0x00000001<br>
0x0804831d 0xbffff914 0x0000002f 0xbffff758 : <strong>sum의 stack frame</strong>  </p>

<blockquote>
<p>0x0804850b 0x00000001 0x00000002 0xbffff800<br>
0xb7e4942d 0xb7fc03c4 0xb7fff000 0x0804856b<br>
0x00000000 0x08048560 0x00000000 0x00000000 : <strong>main의 stack frame</strong></p>
</blockquote>
</blockquote>

<p><strong>Leave</strong> 실행 후에 <strong>func2의 stack frame</strong>이 모두 정리된 것 보이시나여?<br>
그리고 ebp가 sum의 ebp로 바뀌고,<br>
esp도 sum의 esp로 바뀌었습니다.</p>

<p>그리고 <strong>Ret</strong>을 만나면 <strong>0x080484e4로 리턴</strong>해 나머지 sum의 인스트럭션을 실행하고,<br>
끝으로 sum의 stack frame도 정리되고 나머지 main의 인스트럭션을 실행한 후<br>
프로그램을 종료하는 것이겠씀미다아아~</p>

<p>쟈아아아 오늘은 gdb도 써보거 스택에 대해서도 자세히 알아보았눈데,<br>
어떠셔쎄여?</p>

<p>다음 번엔 좀 더 다이나믹한 데이트를 합씨당.<br>
아 물론 데이트 코스는 제가 짭니당. ^ㅠ^
<br></p>

<p><em>다음 포스팅 예고</em></p>

<p><img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-outro.gif" alt=""></p>

<p>그럼 이만 뿅!</p>

	  ]]></description>
	</item>

	<item>
	  <title>우리집에 GDB 있는데... 메모리 보고갈래? (1)</title>
	  <link>/umbrain//gdb-memory-day1</link>
	  <author>taBRis</author>
	  <pubDate>2017-01-22T06:41:00+00:00</pubDate>
	  <guid>/umbrain//gdb-memory-day1</guid>
	  <description><![CDATA[
	     <p><strong>출처 : <a href="https://bpsecblog.wordpress.com/2016/03/08/gdb_memory_1/">우리집에 GDB 있는데&hellip; 메모리 보고갈래? (1) - Hackerz on the Ship</a></strong></p>

<h2>들어가기에 앞서&hellip;</h2>

<blockquote>
<p>컴(존)알못들이여 오라.
보안 공부하다 높다란 진입장벽 앞에서 좌절하신 분들께 이 글을 바칩니다.
해커가 되겠다는 청운을 안고 대학을 입학했으나.. 4년 째 뉴비&hellip;★
컴알못인 제가 자세히 친절하게 하나하나 꼭꼭 씹어보겠습니다.</p>
</blockquote>

<hr>

<h2>Season 1. 우리집에 GDB있는데&hellip; 메모리 보고 갈래?</h2>

<p><br></p>

<h3>DAY #1. 듀근듀규뉸구누균ㄱ 첫만남</h3>

<p><br>
<img src="../assets/Post_Images/2017/01/22/gdb_memory_day1/gdb-memory-day1-intro.png" alt="*인트로*"></p>

<p>구체적으로 뭐하는지가 궁금하시다구여?
…뭘 하더라도 기초가 중요한 것 같네요.
메모리에 대한 썰부터 간단히 풀어볼게요!!
<br></p>

<p><img src="../assets/Post_Images/2017/01/22/gdb_memory_day1/gdb-memory-day1-1.png" alt="">
<em>[그림 1] 썰 주제 되십니다<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></em>
<br></p>

<hr>

<h4>1. 주소는 왜 때문에 0000 0000 ~ FFFF FFFF ???</h4>

<p>램은 몇 기가 쓰세여?<br>
제 노트북은 4GB의 램을 쓰고 있네요.</p>

<p><img src="../assets/Post_Images/2017/01/22/gdb_memory_day1/gdb-memory-day1-2.png" alt="">
<em>[그림 2] 이런거 은근 헷갈리지 않음요?</em>
<br></p>

<p>위의 계산에 의하면 4GB는 2<sup>32</sup> byte 사이즈의 메모리죠.</p>

<p>1Byte는 주소공간 한 개의 크기입니다<br>
즉, 4GB는 2<sup>32</sup> 개의 주소를 가질 수 있어요</p>

<p>그리고 1bit는 0 또는 1의 값만 가질 수 있기 때문에 32bit는 2<sup>32</sup> 만큼의 숫자를 표현할 수 있어요</p>

<p>32bit라는 것은 2<sup>32</sup> 개의 주소를 가지고 있다라는 뜻으로 이해하시면 됩니다!</p>

<p>그런데 우리가 메모리를 뭐로 접근합니까? 주소로 접근 하죠.<br>
32bit 운영체제는 수 표현을 최대 2<sup>32</sup> 까지 밖에 못 하기 때문에, 8GB나 16GB의 램을 가지고 있다고 하더라도 접근을 할 수가 없어요.</p>

<p>0000…0000(32개) 부터 1111….1111(32개) 까지를 보기 편하게 16진수로 변환하면?</p>

<p>00000000 ~ FFFFFFFF !</p>

<hr>

<h4>2. 유저 영역, 커널 영역은 왜 나뉘어져 있나</h4>

<p>시스템 운영에 필요한 메모리, 그리고 운영체제가 커널 영역에 올라가 있습니다.<br>
사용자가 운영체제가 올라가 있는 커널 영역에 마음대로 접근할 수 있다면…? 시스템이 안정적으로 운용될 수 없을거예여.</p>

<p>그렇기 때문에 사용자가 함부로 커널 영역에 접근할 수 없도록 메모리를 유저영역과 커널영역을 나누어 사용하는 겁니다.<br>
나누는 크기는 운영체제마다 다르고, 설정에 따라 영역의 크기를 조정할 수도 있어여.</p>

<hr>

<h4>3. 유저 영역의 메모리</h4>

<p>유저 메모리의 영역을 조금 더 자세히 살펴볼까요?</p>

<p><img src="../assets/Post_Images/2017/01/22/gdb_memory_day1/gdb-memory-day1-3.png" alt="">
<em>[그림 3] 안녕하새오 웬만한 기본서 펼치면 2n 페이지 쯤 있는 친구애오<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup></em>
<br></p>

<h5>3-1. 코드영역</h5>

<p>일단 메모리에 코드가 올라옵니다. 코드가 뭐냐구요?</p>

<p><img src="../assets/Post_Images/2017/01/22/gdb_memory_day1/gdb-memory-day1-4.png" alt="">
<em>[그림 3] 네 바로 이겁니다</em>
<br></p>

<p>이런거 어디서 많이 봤죠? c소스를 컴파일하면 어셈블리 코드로 번역(?)되잖아요.<br>
이 저급한 애들이 코드 영역에 올라 간다는 거져ㅎㅎ<br>
주소보면 32bit 시스템에서 익숙한 0804~로 시작함다. 메모리에 코드1가 올라갈 때 보통 저 영역에 올라갑니다.
<br></p>

<h5>3-2. 데이터영역</h5>

<p>그 다음은 데이터 영역입니다.<br>
전역변수가 이 영역에 로드되는데 항상 동일한 메모리에 위치하게 됩니당.</p>

<p>사용자가 입력하는 값이 전역변수로 정의되어있다고 가정해봅시다.<br>
고정된 메모리 주소 그리고 그 주소에 원하는 값을 쓸 수 있다면? 익스플로잇에 활용될 가능성이 갱장히 높아지겠죠?</p>

<p>여기까지가 고정된 주소에 올라오는 영역입니다.
<br></p>

<h5>3-3. 힙영역</h5>

<p>힙 영역은 동적으로 메모리를 할당하여 사용하는 공간입니다.<br>
대표적인 메모리 할당 함수로는 malloc 이 있죠. malloc으로 필요한 공간을 할당하면 힙 영역을 쓰게 되는겁니다.<br>
쓰다가 필요 없어지면 해제 해주면 되죠.</p>

<p>이 말인 즉슨 내가 힙 영역에 어떤 값을 엄청 많이 뿌려놓고 free 해준 후<br>
다시 이 공간을 재사용한다면..? 후.. 뭔가 익스플로잇할 때 낭낭히 활용될 거 같죠?</p>

<p><em>후.. 방금 당신은 UAF를 배웠습니다.</em>
<br></p>

<h5>3-4. 스택영역</h5>

<p>마지막 두둥 (유저영역) 메모리의 가장 바닥부터 채워지는 스택이 있죠.<br>
스택은 거꾸로 자라는거 아시져?<br>
왜냐구요?<br>
스택이 끝도없이 위아래도 모르고 자라다가 커널 건드리면…. 주옥되잖아요…<br>
그래서 얘는 거꾸로 자라는 겁니다.<br>
스택영역은 함수인자나 지역변수들이 올라옵니다.<br>
보통 스택 주소보면 0xbfff 이런식이예요.  </p>

<p>힙과 스택은 고정된 메모리에 올라오는 것이 아니기 때문에, 이 영역을 활용해 한번에 깔끔하게 쉘 따기란 넘나 어려운 것…</p>

<p>다음 포스팅엔 gdb 활용법으로 찾아오도록 할게여.<br>
메모리 구조를 gdb를 통해 뜯어보는 시간도 가져보도록 하겠슴다. 그럼 뿅★</p>

<p><em>written by in09</em></p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>[그림 1]: Pictogram(crown) created by Paul Verhulst from Noun Project&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>[그림 3]: Pictogram(book) created by Jakub Caja from Noun Project&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

	  ]]></description>
	</item>


</channel>
</rss>
