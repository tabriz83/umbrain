<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>tabriz83.github.io/umbrain/</title>
   
   <link>http://tabriz83.github.io/umbrain/</link>
   <description>Memory Repository.</description>
   <language>en-uk</language>
   <managingEditor> taBRis</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>(完)우리집에 GDB 있는데... 메모리 보고갈래? (3)</title>
	  <link>/umbrain//gdb-memory-day3</link>
	  <author>taBRis</author>
	  <pubDate>2017-01-25T17:14:00+00:00</pubDate>
	  <guid>/umbrain//gdb-memory-day3</guid>
	  <description><![CDATA[
	     <p><strong>출처 : <a href="https://bpsecblog.wordpress.com/2016/05/20/gdb_memory_3/">(完)우리집에 GDB 있는데&hellip; 메모리 보고갈래? (3) - Hackerz on the Ship</a></strong></p>

<h2>Season 1. 우리집에 GDB있는데&hellip; 메모리 보고 갈래?</h2>

<p><br></p>

<h3>DAY #3. 이쯤 했으면 이제 그만 엔터치자</h3>

<p><br>
<img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-intro.jpg" alt="">
오늘부터 1일♡</p>

<hr>

<h4>1) Debugging  (IDA, GDB 사용)</h4>

<p>우리는 이미 tomato.c 소스가 있지만, 보통 소스는 잘 안주잖아여<br>
없다는 가정하에 디버깅을 해봅씨다.
<br></p>

<p><strong>• IDA (취약점 발견 !)</strong><br>
헥스레이라는 강력한 기능을 제공하는 디스어셈블러임다.</p>

<p>헥스레이는 바이너리를 디컴파일해서 원본 코드와 흡사한 소스를 떨궈줍니다.<br>
F5 단축키를 누르면 다음과 같이 디컴파일한 소스가 나옴미다.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-1.png" alt="">
<em>[그림 1] IDA의 HEX-RAY와 원본 소스 비교</em>
<br></p>

<p>헥스레이ㅋ 지리구요 오지구요<br>
유료 툴이지만 넘나 강력한 것.</p>

<p>전 보통 정적 분석할 때 아이다를 활용함다.<br>
(아이다로도 가능하지만, 전 동적으로 디버깅할 땐 보통 gdb를 활용함여)</p>

<p>IDA에서 8번째 라인을 봐주세요.</p>

<p>strcpy((char *) &amp;v4, argv[1]);의 코드에서<br>
buffer overflow 취약점이 나는 것을 손쉽게 확인할 수 있졈?</p>

<p>명령행인자 argv[1]를 v4 변수에 복사할 때 버퍼 크기를 검증하는 라인은 그 어디에도 없쟈나요.</p>

<p>변수 v4와 v5는 지역변수이기 때무네 스택 영역에 할당 되는데요.</p>

<p>length가 검증되지 않은 v4에 argv[1]의 값이 복사될 때,<br>
v4는 할당받은 공간 그 이상을 활용할 수 있게되거<br>
v5가 v4보다 높은 주소에 할당되어 있다면..?</p>

<p>v5에 원하는 값을 삽입할 수 있겠죠?<br>
(strcpy는 버퍼 오버플로우 취약점이 발생할 가능성이 농후하기 때문에 strcpy_s로 대체해 사용하길 권고하고 있슴다.)
<br></p>

<p><strong>• GDB ( 발견한 취약점으로 동적 분석 ㄱㄱ)</strong><br>
취약점이 발생한 strcpy를 call할 때 스택을 봐보겠슴다.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-2.png" alt="">
<em>[그림 2] main의 assembly code</em></p>

<p>strcpy 함수를 call하기 전에 스택에 매개인자들을 넣어줘여.
<br></p>

<p>0x0804851e에 breakpoint를 걸고, <strong>strcpy가 실행되기 전후의 스택</strong>을 보겠슴다.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-3.png" alt="">
<em>[그림 3] tomato 바이너리 실행</em>
<br></p>

<p>breakpoint 건 후, 명령행인자(argv[1])에 aaaaaaaa를 넘기고 실행해써요.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-4.png" alt="">
<em>[그림 4] strcpy 호출 전후</em>
<br></p>

<p>v4에 값이 잘 들어갔져?<br>
여기서 약간의 부연설명을 하도록 하겠습니다.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-5.png" alt="">
<em>[그림 5] strcpy 호출 전 assembly code 일부 발췌</em>
<br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">0x08048517 &lt;+49&gt;: lea eax,[esp+0x12]
0x0804851b &lt;+53&gt;: mov DWORD PTR [esp],eax
</code></pre></div>
<p>esp가 가리키는 값은 esp+0x12져?<br>
즉, v4의 값은 esp+0x12에 들어있는 거예여.</p>

<p>[그림 4]에서 esp가 가리키는 값, 즉 <strong>0xbfff692</strong>는 <strong>esp+0x12</strong>가 되겠졈?</p>

<p>다음은 [그림 2]의 main의 어셈코드에서 일부입니당.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-6.png" alt="">
<em>[그림 6] v5값을 비교하는 assembly code</em>
<br></p>

<p>esp+0x1c 값이 0x1 이면 system 함수가 실행되고,<br>
같지 않으면 0x0804854a &lt;+100&gt; :    mov  eax, 0x0으로 분기하네요.</p>

<p>잠시 [그림 1]의 IDA에서 main의 선언부를 보도록 하겠슴다.</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-7.png" alt="">
<em>[그림 7] main 변수 선언</em>
<br></p>

<p>주석을 보면 v4는 [sp+12h]  [bp-Eh]<br>
v5는 [sp+1Ch] [bp-4h] 라고 보여지네요.</p>

<p>이 말인 즉슨, main의 stack frame의 esp, ebp를 기준으로,<br>
v4와 v5가 어디에 할당이 되어있는지 알 수 있어여.</p>

<p>assembly code를 보면 esp를 기준으로 v4와 v5에 값이 할당되고 있으니,<br>
esp를 기준으로 stack을 그려보도록 하겠습니다!</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-8.png" alt="">
<em>[그림 8] main의 스택</em>
<br></p>

<p>즉, v4의 값이 흘러넘치면~? v5에도 영향을 미칠 수 있겠죻ㅎㅎ<br>
확인해볼까요?</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-9.png" alt="">
<em>[그림 9] buffer overflow 발생, strcpy 직후 stack</em>
<br></p>

<p>[그림 6]의 assembly code에서 ESP+0X1C(v5) 값이 1이면<br>
system 함수를 호출하는 조건문 안으로 들어갈 수 있었기 때문에,<br>
이제 v5가 0x00000001이 되면 셸을 띄울 수 있겠죵?</p>

<hr>

<h4>2) EXPLOIT</h4>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-10.png" alt="">
<em>[그림 10] v5에 00000001 넣는 방법 (실패)</em>
<br></p>

<p>에휴.. 쉘이 안뜬거 보니 실패했네여&hellip;<br>
왜 그런가 한번 gdb로 봐보댜구요.
<br></p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-11.png" alt="">
<em>[그림 11] 왜 때문에 실패?</em>
<br></p>

<p>내가 원하는건 이거자나여..</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-12.png" alt="">
<em>[그림 12] 이걸 원하는건데..ㅠ 왜 때무네 [그림 11]처럼 되는거지ㅠ</em>
<br></p>

<p>우리는 문자열 00000001이 아닌 버퍼에 0x00000001을 넣고 싶은거자나요.<br>
근데 문자열로 들어가버려서 fail..★</p>

<p>hex 값을 입력하기 위해서는 평소 command line에서 입력하듯이 할 수 없어여.<br>
그래서 python이나 perl과 같은 언어의 힘을 빌려야함당.</p>

<p>python을 사용해서 해보도록 할게요!</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-13.png" alt="">
<em>[그림 13] python으로 command line에서 출력하기</em>
<br></p>

<p>python에서 -c 옵션을 활용하면 command 라인에서 출력을 할 수 있어요.</p>

<p>python으로는 hex 값을 표현할 수 있기 때문에,<br>
이를 활용해 출력값을 in09 파일에 저장한 것이 보이졈?<br>
(in09 파일에서 보이는  <sup>@<sup>@<sup>@<sup>A는</sup></sup></sup></sup> 헥스값으로 0x00000001임다)</p>

<p>그리고 쉘 프롬프트에서 사용하는 <strong>`(백틱)</strong>에 대해<br>
잠깐 설명하고 넘어가도록 하겠슴미다.</p>

<p>우리는 명령행인자로 ‘in09 파일의 출력 값’을 넘겨야해요..ㅠ<br>
이럴 때 활용할 수 있는 것이 바로 `(백틱)인데요.<br>
쉘 커맨드의 출력 값을 리턴해주는 용도로 활용됩니다.  </p>

<p>뭔 말이냐면여..</p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-14.png" alt="">
<em>[그림 14] 백틱의 활용 예</em>
<br></p>

<p>whoami라는 명령어의 출력 값은 in09임다.</p>

<p>이 shell command를 `으로 감싸서, tomato 바이너리의 명령행인자로 넘기면<br>
whoami 명령어의 출력 값이 입력 값으로 넘어가고 있어요(arr을 보세요)!  </p>

<p>어떻게 활용하는지 감이 오시냐염?</p>

<hr>

<h4>3) FINAL</h4>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-15.png" alt="">
<em>[그림 15] exploit 성공! (1)</em></p>

<p>셸이 뿅★<br>
출력 값을 in09 파일에 저장했었졈? 그걸 활용해도 되고여,
<br></p>

<p><img src="../assets/Post_Images/2017/01/25/gdb_memory_day3/gdb-memory-day3-16.png" alt="">
<em>[그림 16] exploit 성공! (2)</em></p>

<p>바로 활용해도 됨다.<br>
오예!
<br></p>

<hr>

<p>드디어 gdb 시리즈가 끝났슘다.</p>

<p>뉴비들의 교과서를 쓰고 싶었는데 아쉬움이 남네요ㅠ<br>
무엇보다 이제 이런 되도 않는 컨셉은 버려야겠어요ㅋ..</p>

<p>감사함미다 뿅!</p>

<p>-written by in09</p>

	  ]]></description>
	</item>

	<item>
	  <title>우리집에 GDB 있는데... 메모리 보고갈래? (2)</title>
	  <link>/umbrain//gdb-memory-day2</link>
	  <author>taBRis</author>
	  <pubDate>2017-01-24T01:56:00+00:00</pubDate>
	  <guid>/umbrain//gdb-memory-day2</guid>
	  <description><![CDATA[
	     <p><strong>출처 : <a href="https://bpsecblog.wordpress.com/2016/04/04/gdb_memory_2/">우리집에 GDB 있는데&hellip; 메모리 보고갈래? (2) - Hackerz on the Ship</a></strong></p>

<h2>Season 1. 우리집에 GDB있는데&hellip; 메모리 보고 갈래?</h2>

<p><br></p>

<h3>DAY #2. 애프터 신청 (<del>너</del> gdb 사용법, 갖고싶다.. 너란 stack)</h3>

<p><br>
<img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-intro.png" alt="*인트로*">
<br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">//tomato.c

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;&#39;

void func2() {
    puts(&quot;func2()&quot;);
}

void sum(int a, int b) {
    printf(&quot;sum : %d\n&quot;, a+b);
    func2();
}

int main(int argc, char *argv[]) {

    int num=0;
    char arr[10];

    sum(1,2);
    strcpy(arr,argv[1]);
    printf(&quot;arr: %s\n&quot;, arr);
    if(num==1){
        system(&quot;/bin/sh&quot;);
    }
    return 0;
}
</code></pre></div>
<p><br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">in09@ubuntu:~/bpsecblog/day2$ gcc -fno-stack-protector -o tomato tomato.c
</code></pre></div>
<blockquote>
<p><strong>-fno-stack-protector 옵션을 포함하는 이유</strong><br>
gcc가 스택을 보호하기 위해 ‘canary’라는 것을 삽입해요.<br>
함수 내에서 사용하는 스택 프레임과 return address 사이에<br>
canary를 넣어염.</p>

<p>Buffer Overflow가 발생해 canary를 덮었을 때,<br>
이를 감지하고 프로그램을 강제 종료 해 버린답니당.</p>

<p>이를 <strong>SSP</strong>(Stack Smashing Protection)이라고 해요.</p>

<p>여기에선 오버플로우가 발생해도 프로그램이 강제 종료되지 않도록,<br>
<strong>–fno-stack-protector</strong> 옵션을 사용해 <strong>보호기법을 해제</strong>한겁니답.</p>

<p>반대로 모든 프로시져에 이 <strong>보호기법을 적용</strong>하기 위해서는,<br>
<strong>-fstack-protector-all</strong> 옵션을 사용하세염</p>

<p><a href="https://bpsecblog.wordpress.com/2016/03/26/watermelon-feat-%ec%b6%9c%ec%a0%9c%ec%9e%90-in09/">[Go to Watermelon]</a><br>
(CodeGate2016 watermelon writeup에서<br>
canary에 대한 자세한 내용이 있으니 참고하셔도 좋습니당!)</p>
</blockquote>

<p><br></p>

<p>이제 GDB를 활용해보도록 할까욤?</p>

<hr>

<h4>Ch 1. <del>너</del>  gdb 사용법</h4>

<p><br></p>

<p><img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-intro2.png" alt=""></p>

<blockquote>
<p>하라니까 하겠는데.<br>
근데 GDB를 왜 써야되는데?</p>
</blockquote>

<p><br></p>

<p>지..진정하세요.</p>

<p>gdb는 오픈소스로 공개되어있는 무료 디버거랍니다.<br>
아 디버거가 뭐냐거여?</p>

<p>님들 해답지보고 공부할 때,<br>
왜 이러저러하게 이 답이 도출이 되는지 보잖아요.</p>

<p>디버거도 그런검미다.<br>
코드에서 이 라인을 실행할 때, 어떤 값이 어떤 메모리 주소에 올라가고<br>
그 과정을 보여주는거져.</p>

<p>컴퓨터 계의 X-RAY랄까?  </p>

<p>gdb를 쓰면 물론 콘솔 기반이라.. 빡치긴 해여..<br>
ida 봐봐여… 아름답잖아요..</p>

<p>하지만 ELF 파일과 같은 Linux 기반의 실행파일을<br>
동적으로 따라가며 분석할 때 gdb 참 쓸만하져.</p>

<p>그래서 이거 씀미다.</p>

<p>긍까 쫄지말고 긔긔.</p>

<hr>

<p>GDB로 tomato를 실행시켜봅시당.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">in09@ubuntu:~/bpsecblog/day2$ gdb ./tomato
</code></pre></div>
<p>이건 그냥 gdb로 tomato에 붙은 것에 불과해여.<br>
아직 우리의 토마토는 실행되지 않았담미다.</p>

<p>일단 gdb 켜봤으면 뭐.. 어셈도 한번 봐주고,<br>
tomato를 실행하기 전에 이것 저것 설정도 해줘야쥬?</p>

<p>일단 보기 편하게 어셈 코드를 intel 형식으로 설정해<br>
main을 출력해 보겠습니답.ㅎㅎ</p>

<blockquote>
<p><strong>set disassembly-flavor [명령어 형식]</strong><br>
어셈블리 코드 문법을 설정하는 명령어.<br>
x86에서 Intel과 at&amp;t 둘 중 하나를 골라 쓰면 됨.<br>
[명령어 형식의 예] : intel, att</p>

<p><strong>disas [함수이름]</strong><br>
함수의 어셈블리 코드를 보는 명령어.</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) set disassembly-flavor intel  
(gdb) disas main  
      Dump of assembler code for function main:  
         0x080484e6 &lt;+0&gt;: push   ebp  
         0x080484e7 &lt;+1&gt;: mov    ebp,esp  
         0x080484e9 &lt;+3&gt;: and    esp,0xfffffff0  
         0x080484ec &lt;+6&gt;: sub    esp,0x20  
         0x080484ef &lt;+9&gt;: mov    DWORD PTR [esp+0x1c],0x0  
         0x080484f7 &lt;+17&gt;: mov    DWORD PTR [esp+0x4],0x2  
         0x080484ff &lt;+25&gt;: mov    DWORD PTR [esp],0x1  
         0x08048506 &lt;+32&gt;: call   0x80484c1 &lt;sum&gt;  
         0x0804850b &lt;+37&gt;: mov    eax,DWORD PTR [ebp+0xc]  
         0x0804850e &lt;+40&gt;: add    eax,0x4  
         0x08048511 &lt;+43&gt;: mov    eax,DWORD PTR [eax]  
         0x08048513 &lt;+45&gt;: mov    DWORD PTR [esp+0x4],eax  
         0x08048517 &lt;+49&gt;: lea    eax,[esp+0x12]  
         0x0804851b &lt;+53&gt;: mov    DWORD PTR [esp],eax  
         0x0804851e &lt;+56&gt;: call   0x8048360 &lt;strcpy@plt&gt;  
         0x08048523 &lt;+61&gt;: lea    eax,[esp+0x12]  
         0x08048527 &lt;+65&gt;: mov    DWORD PTR [esp+0x4],eax  
         0x0804852b &lt;+69&gt;: mov    DWORD PTR [esp],0x8048602  
         0x08048532 &lt;+76&gt;: call   0x8048350 &lt;printf@plt&gt;  
         0x08048537 &lt;+81&gt;: cmp    DWORD PTR [esp+0x1c],0x1  
         0x0804853c &lt;+86&gt;: jne    0x804854a &lt;main+100&gt;  
         0x0804853e &lt;+88&gt;: mov    DWORD PTR [esp],0x804860b  
         0x08048545 &lt;+95&gt;: call   0x8048380 &lt;system@plt&gt;  
         0x0804854a &lt;+100&gt;: mov    eax,0x0  
         0x0804854f &lt;+105&gt;: leave  
         0x08048550 &lt;+106&gt;: ret  
      End of assembler dump.
</code></pre></div>
<p>메인이 이렇게 구성되어 있네요.</p>

<p>main에 breakpoint를 걸고 한번 실행해 볼까요?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">0x080484e6 &lt;+0&gt;: push   ebp
</code></pre></div>
<p>이게 main의 시작이잖아요?</p>

<blockquote>
<p><strong>b *[메모리주소]</strong><br>
breakpoint를 거는 명령.</p>

<p><u>[메모리 주소]</u>나 <u>[함수의 이름]</u> 혹은,<br>
이를 기준으로 한 <u>[offset &lt;+0&gt;]</u>으로<br>
breakpoint를 걸어도 됩니당.</p>

<p>* breakpoint를 걸 땐, 주소 앞에 *를 붙이세요!</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) b *main
Breakpoint 1 at 0x80484e6
(gdb) b *0x080484e6
Note: breakpoint 1 also set at pc 0x80484e6
Breakpoint 2 at 0x80484e6
(gdb) b *main+0
Note: breakpoints 1 and 2 also set at pc 0x80484e
Breakpoint 3 at 0x80484e6
</code></pre></div>
<p>모두 똑같은 곳에 breakpoint가 걸렸죠?
<br></p>

<p><strong>breakpoint</strong> 정보를 확인해볼게용</p>

<blockquote>
<p><strong>info b</strong><br>
breakpoint 정보를 열람할 수 있는 명령어</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) info b
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x080484e6 &lt;main&gt;
2       breakpoint     keep y   0x080484e6 &lt;main&gt;
3       breakpoint     keep y   0x080484e6 &lt;main&gt;
</code></pre></div>
<p><br></p>

<p><strong>Breakpoint</strong>가 중복되니 삭제해보도록 하겠습니당</p>

<blockquote>
<p><strong>d (breakpoint 번호)</strong><br>
breakpoint를 삭제 할 수 있는 명령어</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) d 2
(gdb) d 3
(gdb) info b
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x080484e6 &lt;main&gt;
</code></pre></div>
<p><br></p>

<p>이제 <strong>프로그램을 실행</strong>해볼게요!<br>
이제야 비로소.. 아 토마토 다 뿔었겠네. ㅡㅡ</p>

<blockquote>
<p><strong>run [매개변수]</strong><br>
gdb 내부에서 프로그램 실행</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) run aaaaaaaaaa
Starting program: /home/in09/bpsecblog/day2/tomato aaaaaaaaaa
Breakpoint 1, 0x080484e6 in main ()
(gdb)
</code></pre></div>
<p>헌데 명령행 인자로 main의 매개변수에 값이 넘어가죠?<br>
그래서 “aaaaaaaaa” 스트링을 넘겨준 거예요.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">in09@ubuntu:~/bpsecblog/day2$ ./tomato aaaaaaaaaa
 sum : 3
 func2()
 arr: aaaaaaaaaa 
</code></pre></div>
<p>터미널에서 위와 같이 실행하는 것과 동일한거죠!
<br></p>

<p>현재 우리 실행 흐름이 어디에 있는지 EIP를 확인해볼게요! Main에 멈춰있어야겠죠?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">gdb) disas main
Dump of assembler code for function main:
=&gt; 0x080484e6 &lt;+0&gt;: push   ebp
   0x080484e7 &lt;+1&gt;: mov    ebp,esp
   0x080484e9 &lt;+3&gt;: and    esp,0xfffffff
   0x080484ec &lt;+6&gt;: sub    esp,0x20
</code></pre></div>
<p>=&gt; 화살표가 보이졍?<br>
아주 잘 멈춰져있네요.<br>
인스트럭션을 한줄 한줄 실행해볼게염.</p>

<blockquote>
<p><strong>ni</strong>
다음 인스트럭션 실행</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) ni
0x080484e7 in main ()
(gdb) ni
0x080484e9 in main ()
(gdb) disas main
Dump of assembler code for function main:
   0x080484e6 &lt;+0&gt;: push   ebp
   0x080484e7 &lt;+1&gt;: mov    ebp,esp
=&gt; 0x080484e9 &lt;+3&gt;: and    esp,0xfffffff0
   0x080484ec &lt;+6&gt;: sub    esp,0x20
</code></pre></div>
<p>현재 EIP가 멈춰져있는 곳 이 전의 밑줄 친 <u>인스트럭션</u>을 보면,<br>
esp 값을 ebp 값에 저장하고 있죠?</p>

<p>esp, ebp는 스택과 관련한 레지스터잖아요!<br>
그 메모리에 어떤 값이 담겨있는지 gdb로 확인해보도록 하게씀미당.
<br></p>

<p>그 전에 메모리 출력 방식에 대해 정리하고 가도록 할게요.<br>
<strong>몇 바이트</strong>만큼 그리고 <strong>몇 진법</strong>으로 출력할 것인지 정해 옵션을 주어 출력해 주면 됨미다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/b 0x080484e6
0x80484e6 &lt;main&gt;: 0x55
(gdb) x/h 0x080484e6
0x80484e6 &lt;main&gt;: 0x8955
(gdb) x/w 0x080484e6
0x80484e6 &lt;main&gt;: 0x83e58955
</code></pre></div>
<p>해당 메모리 주소의 값을 각각 1바이트, 2바이트, 4바이트만큼 출력해주었습니다.</p>

<p><br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/x 0x080484e6
0x80484e6 &lt;main&gt;: 0x83e58955
(gdb) x/u 0x080484e6
0x80484e6 &lt;main&gt;: 2212858197
</code></pre></div>
<p>해당 메모리 주소 값을 16진수, 10진수로 출력해주었습니다.<br>
보통 이렇게들 씁니당.<br>
(진법 옵션이든 바이트 옵션이든 생략되면 이전 옵션으로 실행해줍니다.)</p>

<p><br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/wx 0x080484e6
0x80484e6 &lt;main&gt;: 0x83e58955
(gdb) x/4b 0x080484e6
0x80484e6 &lt;main&gt;: 0x55 0x89 0xe5 0x83
</code></pre></div>
<p>헙.. 근데 순서가 조금 이상하죠?
4바이트 출력한 것과 1바이트씩 4개를 출력한 것과 순서가 반대예요!
이것은 <strong>바이트 오더링</strong> 개념에 대해 이해를 해야 하는데요.</p>

<blockquote>
<p><strong>Byte Ordering [Big Endian / Little Endian]</strong>  </p>

<p>Intel CPU는 바이트를 배열할 때 <u>거꾸로 쓰게</u> 됩니다.<br>
예를 들어 0x12345678을 저장한다고 하면, <strong>0x78563412</strong>와 같이 거꾸로 저장하게 됩니다.<br>
이를 <strong><u>Little Endian</u></strong>이라 지칭합니다.</p>

<p>반면, gdb는 디버깅 시에 보기 편하게 하기 위해서<br>
Big Endian 형식으로 <strong>0x12345678</strong>와 같이 출력해주기 때문에,<br>
1바이트씩 출력할 때와 4바이트로 출력할 때 달리 보이는 거예요.</p>

<p>• 참고로 네트워크 상에서는 <u><strong>Big Endian</strong></u> 형식의 바이트 오더링을 사용합니다.</p>
</blockquote>

<p><br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/4wx $esp
0xbffff6b8: 0x00000000 0xb7e2fa83 0x00000002 0xbffff754
</code></pre></div>
<p>특정 레지스터를 기준으로 메모리 값을 보고 싶으면,<br>
$register_name으로 출력해볼 수 있습니당.
<br></p>

<p>다음은 ebp와 esp를 출력하는 것이고,<br>
info reg 혹은 i r은 레지스터 정보를 출력하는 명령입니답.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/wx $ebp
0xbffff6b8: 0x00000000
(gdb) x/wx $esp
0xbffff6b8: 0x00000000
(gdb) info reg $ebp
ebp            0xbffff6b8 0xbffff6b8
(gdb) i r $ebp $esp
ebp            0xbffff6b8 0xbffff6b8
esp            0xbffff6b8 0xbffff6b8
(gdb) i r
eax            0x2 2
ecx            0x7ce225d5 2095195605
edx            0xbffff6e4 -1073744156
ebx            0xb7fc0000 -1208221696
esp            0xbffff6b8 0xbffff6b8
ebp            0xbffff6b8 0xbffff6b8
esi            0x0 0
edi            0x0 0
eip            0x8048480 0x8048480 &lt;main+3&gt;
eflags         0x246 [ PF ZF IF ]
cs             0x73 115
ss             0x7b 123
ds             0x7b 123
es             0x7b 123
fs             0x0 0
gs             0x33 51
</code></pre></div>
<p>자.. 이제 gdb 사용법은 거진 다 익힌 것 같아요.</p>

<p>이제 우리 좀 더 알아가볼까요..?ㅎㅎ</p>

<hr>

<h4>Ch 2. 갖고싶다.. 너란 stack..</h4>

<p><br></p>

<p><img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-1.png" alt="">
<em>[그림 1] Stack과 관련한 레지스터</em>
<br></p>

<p>• 현재 EIP 상황(main 2줄 실행)  </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">  0x080484e6 &lt;+0&gt;: push   ebp
  0x080484e7 &lt;+1&gt;: mov    ebp,esp
=&gt;0x080484e9 &lt;+3&gt;: and    esp,0xfffffff0
  0x080484ec &lt;+6&gt;: sub    esp,0x20
  0x080484ef &lt;+9&gt;: mov    DWORD PTR [esp+0x1c],0x0
  0x080484f7 &lt;+17&gt;: mov    DWORD PTR [esp+0x4],0x2
  0x080484ff &lt;+25&gt;: mov    DWORD PTR [esp],0x1
  0x08048506 &lt;+32&gt;: call   0x80484c1 &lt;sum&gt;
</code></pre></div>
<p><br></p>

<h5>1. 스택의 시작</h5>

<blockquote>
<p><em>PUSH EBP</em><br>
<em>MOV EBP, ESP</em></p>
</blockquote>

<p>단 두 줄의 인스트럭션만 실행이 되었기 때문에 별 건 없져?<br>
하지만 저 단 두 줄의 어셈이 의미하는 바는 상당합니다.<br>
바로 <mark>&lsquo;스택(프레임)이 생성&rsquo;</mark>이 된다는 것이죠.</p>

<p>저 두 줄의 의미는,  </p>

<blockquote>
<p><mark>&#39;함수가 실행이 될 때, 그 이전의 ebp(sfp)를 스택에 push하고<br>
현재 esp를 ebp에 저장하라.(새로운 ebp 생성!)&rsquo;</mark></p>
</blockquote>

<p>이라는 뜻임미당.
<br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">0x08048506 &lt;+32&gt;: call   0x80484c1 &lt;sum&gt;
</code></pre></div>
<p>여기에 breakpoint를 걸고 실행시킨 후 스택의 상황을 보겠습니답.<br>
breakpoint까지 한 번에 뛰려면 c 명령을 사용하면 됩니당.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) b *main+32
Breakpoint 2 at 0x8048506
(gdb) c
Continuing.
Breakpoint 2, 0x08048506 in main ()
(gdb) disas main
Dump of assembler code for function main:
  0x080484e6 &lt;+0&gt;: push   ebp
  0x080484e7 &lt;+1&gt;: mov    ebp,esp
  0x080484e9 &lt;+3&gt;: and    esp,0xfffffff0 
  0x080484ec &lt;+6&gt;: sub    esp,0x20
  0x080484ef &lt;+9&gt;: mov    DWORD PTR [esp+0x1c],0x0
  0x080484f7 &lt;+17&gt;: mov    DWORD PTR [esp+0x4],0x2
  0x080484ff &lt;+25&gt;: mov    DWORD PTR [esp],0x1
=&gt;0x08048506 &lt;+32&gt;: call   0x80484c1 &lt;sum&gt;
</code></pre></div>
<p>원하는 곳에 멈춰잇쪄?</p>

<p>• sum이 call되기 전 상황
<img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-2.png" alt="">
<em>[그림 2] sum이 call되기 전 상황</em>
<br></p>

<p>그리고 sum 함수 안으로 들어가보도록 하겠습니다.<br>
call을 할 때는, 다음 인스트럭션의 주소를 스택에 쌓고 가죠?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">0x08048506 &lt;+32&gt;: call   0x80484c1 &lt;sum&gt;
0x0804850b &lt;+37&gt;: mov    eax,DWORD PTR [ebp+0xc]
</code></pre></div>
<p>call sum에 breakpoint를 걸고 (0x080484c1)<br>
sum 안으로 들어가면,</p>

<p><strong>스택에 ESP(0x00000001)위에 0x0804850b가 쌓였을 거예여.</strong></p>

<p>확인해볼까욤?</p>

<p>• sum이 call된 후의 상황
<img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-3.png" alt="">
<em>[그림 3] sum이 call된 후의 상황</em>
<br></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/10i $eip
=&gt; 0x80484c1 &lt;sum&gt;: push   ebp
   0x80484c2 &lt;sum+1&gt;: mov    ebp,esp
   0x80484c4 &lt;sum+3&gt;: sub    esp,0x18
   0x80484c7 &lt;sum+6&gt;: mov    eax,DWORD PTR [ebp+0xc]
...생략...
(gdb) ni
</code></pre></div>
<p>sum 함수 안으로 들어왔쪄?</p>

<p>오 역시나..</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Push ebp
mov  ebp, esp
</code></pre></div>
<p>하고 있어욤.</p>

<p><em>Push ebp</em>를 실행하면,<br>
그 이전 스택 프레임(main)의 ebp가<br>
sum의 스택 프레임에 push될거예여.</p>

<p>즉, main의 ebp 0xbffff758가 esp에 들어가겠쬬?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) ni
(gdb) x/wx $esp
0xbffff728: 0xbffff758
</code></pre></div>
<p>오오… 마쟈마쟈ㅠㅠ</p>

<p>그리고 <code class="prettyprint">mov ebp, esp</code>를 하면,<br>
현재 esp를 sum stack frame의 바닥</p>

<p>즉, sum의 ebp로 만들어주겠져?</p>

<p>그러므로 sum의 ebp에는 main의 ebp가 있게되겠져.</p>

<p><img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-4.png" alt="">
<em>[그림 4] sum 함수에 들어갔을 때 ebp의 변화</em>
<br></p>

<p>이제 새로운 sum의 스택 프레임이 생성되었습니다!!<br>
확인해볼까요?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/15wx $ebp
0xbffff728: 0xbffff758 0x0804850b 0x00000001 0x00000002
0xbffff738: 0xbffff800 0xb7e4942d 0xb7fc03c4 0xb7fff000
0xbffff748: 0x0804856b 0x00000000 0x08048560 0x00000000
0xbffff758: 0x00000000 0xb7e2fa83 0x00000002
</code></pre></div>
<blockquote>
<p>0xbffff758 : <strong>sum의 stack frame</strong></p>

<blockquote>
<p>0x0804850b 0x00000001 0x00000002<br>
0xbffff800 0xb7e4942d 0xb7fc03c4 0xb7fff000<br>
0x0804856b 0x00000000 0x08048560 0x00000000<br>
0x00000000 : <strong>main의 stack frame</strong></p>
</blockquote>
</blockquote>

<p>이제 새로운 sum의 스택 프레임이 생성되었습니다!!<br>
(현재 tomato.c에서 sum(1,2)라인이 실행 중이겠져?)
<br></p>

<p>상단의 스택을 첫줄만 간추려보도록 하겠습니당.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">0xbffff728: 0xbffff758 0x0804850b 0x00000001 0x00000002
</code></pre></div>
<p><img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-5.png" alt="">
<em>[그림 5] ebp를 기준으로 보쎄용</em>
<br></p>

<p>보이심까?</p>

<blockquote>
<p><mark>새로운 스택 프레임의 ebp를 기준으로<br>
<strong>return address</strong>는 <strong>ebp-4</strong>,<br>
<u>매개인자</u>는 <u>ebp-8</u>, ebp -12와 같이 들어가게 됩니다!</mark></p>
</blockquote>

<p>꼭 기억하세욤~
<br></p>

<blockquote>
<p><strong>c</strong><br>
프로그램이 gdb로 run된 이후에<br>
다음 중단점까지 실행하는 명령어</p>
</blockquote>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/10i $eip
=&gt; 0x80484c4 &lt;sum+3&gt;: sub    esp,0x18
   0x80484c7 &lt;sum+6&gt;: mov    eax,DWORD PTR [ebp+0xc]
   0x80484ca &lt;sum+9&gt;: mov    edx,DWORD PTR [ebp+0x8]
   0x80484cd &lt;sum+12&gt;: add    eax,edx
   0x80484cf &lt;sum+14&gt;: mov    DWORD PTR [esp+0x4],eax
   0x80484d3 &lt;sum+18&gt;: mov    DWORD PTR [esp],0x80485f8
   0x80484da &lt;sum+25&gt;: call   0x8048350 &lt;printf@plt&gt;
   0x80484df &lt;sum+30&gt;: call   0x80484ad &lt;func2&gt;
   0x80484e4 &lt;sum+35&gt;: leave 
   0x80484e5 &lt;sum+36&gt;: ret
(gdb) b *0x080484ad
Breakpoint 4 at 0x80484ad
(gdb) c
Continuing.
sum : 3
Breakpoint 4, 0x080484ad in func2 ()
(gdb) x/i $eip
=&gt; 0x80484ad &lt;func2&gt;: push   ebp
(gdb) ni
0x080484ae in func2 ()
(gdb) x/i $eip
=&gt; 0x80484ae &lt;func2+1&gt;: mov    ebp,esp
(gdb) ni
   0x080484b0 in func2 ()
</code></pre></div>
<p>자.. 또 sum 안에서 func2를 호출했어요.</p>

<p>그럼 아마 스택의 모습은<br>
<strong>| func2 stack frame | sum stack frame | main stack frame|</strong> 과 같이 되겠져?</p>

<p>확인해볼게염.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/23wx $ebp
0xbffff708: 0xbffff728 0x080484e4 0x080485f8 0x00000003
0xbffff718: 0x00000001 0x0804831d 0xbffff914 0x0000002f
0xbffff728: 0xbffff758 0x0804850b 0x00000001 0x00000002
0xbffff738: 0xbffff800 0xb7e4942d 0xb7fc03c4 0xb7fff000
0xbffff748: 0x0804856b 0x00000000 0x08048560 0x00000000
0xbffff758: 0x00000000 0xb7e2fa83 0x00000002 
</code></pre></div>
<blockquote>
<p>0xbffff728 : <strong>func2의 stack frame</strong>  </p>

<blockquote>
<p>0x080484e4 0x080485f8 0x00000003<br>
0x00000001 0x0804831d 0xbffff914 0x0000002f<br>
0xbffff758 : <strong>sum의 stack frame</strong>  </p>

<blockquote>
<p>0x0804850b 0x00000001 0x00000002<br>
0xbffff800 0xb7e4942d 0xb7fc03c4 0xb7fff000<br>
0x0804856b 0x00000000 0x08048560 0x00000000<br>
0x00000000 0xb7e2fa83 0x00000002 : <strong>main의 stack frame</strong></p>
</blockquote>
</blockquote>
</blockquote>

<p>시작이 있으면 끝이 있겠져?<br>
스택의 프레임이 시작되는,<br>
<code class="prettyprint">Push ebp</code><br>
<code class="prettyprint">mov ebp, esp</code>를 자세히 살펴보았으니,</p>

<p>스택 프레임의 끝<br>
<strong>Leave</strong>, <strong>Ret</strong>을 살펴보도록 하겠습니다.</p>

<p><br></p>

<h5>2. stack의 끝</h5>

<blockquote>
<p><strong>Leave</strong><br>
<strong>Ret</strong></p>
</blockquote>

<p><strong>• 현재 EIP 상황</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) disas func2
Dump of assembler code for function func2:
   0x080484ad &lt;+0&gt;: push   ebp
   0x080484ae &lt;+1&gt;: mov    ebp,esp
   0x080484b0 &lt;+3&gt;: sub    esp,0x18
   0x080484b3 &lt;+6&gt;: mov    DWORD PTR [esp],0x80485f0
   0x080484ba &lt;+13&gt;: call   0x8048370 &lt;puts@plt&gt;
=&gt; 0x080484bf &lt;+18&gt;: leave 
   0x080484c0 &lt;+19&gt;: ret
</code></pre></div>
<p><br></p>

<p><strong>• <u>leave 실행 전의 스택 상황</u></strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) x/28wx $esp
0xbffff6f0: 0x080485f0 0x080485f8 0xbffff714 0xb7e63280
0xbffff700: 0x00000003 0xb7fff938 0xbffff728 0x080484e4
0xbffff710: 0x080485f8 0x00000003 0x00000001 0x0804831d
0xbffff720: 0xbffff914 0x0000002f 0xbffff758 0x0804850b
0xbffff730: 0x00000001 0x00000002 0xbffff800 0xb7e4942d
0xbffff740: 0xb7fc03c4 0xb7fff000 0x0804856b 0x00000000
0xbffff750: 0x08048560 0x00000000 0x00000000 0xb7e2fa83
(gdb) i r $ebp $esp
ebp            0xbffff708 0xbffff708
esp            0xbffff6f0 0xbffff6f0
</code></pre></div>
<blockquote>
<p>0x080485f0 0x080485f8 0xbffff714 0xb7e63280<br>
0x00000003 0xb7fff938 0xbffff728 : <strong>func2의 stack frame</strong>  </p>

<blockquote>
<p>0x080484e4<br>
0x080485f8 0x00000003 0x00000001 0x0804831d<br>
0xbffff914 0x0000002f 0xbffff758 : <strong>sum의 stack frame</strong>  </p>

<blockquote>
<p>0x0804850b<br>
0x00000001 0x00000002 0xbffff800 0xb7e4942d<br>
0xb7fc03c4 0xb7fff000 0x0804856b 0x00000000<br>
0x08048560 0x00000000 0x00000000 : <strong>main의 stack frame</strong></p>
</blockquote>
</blockquote>
</blockquote>

<p><br></p>

<p><strong>• leave 실행 후의 스택 상황</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) ni
0x080484c0 in func2 ()
(gdb) x/20wx $esp
0xbffff70c: 0x080484e4 0x080485f8 0x00000003 0x00000001
0xbffff71c: 0x0804831d 0xbffff914 0x0000002f 0xbffff758
0xbffff72c: 0x0804850b 0x00000001 0x00000002 0xbffff800
0xbffff73c: 0xb7e4942d 0xb7fc03c4 0xb7fff000 0x0804856b
0xbffff74c: 0x00000000 0x08048560 0x00000000 0x00000000
(gdb) i r $ebp $esp
ebp            0xbffff728 0xbffff728
esp            0xbffff70c 0xbffff70c
</code></pre></div>
<blockquote>
<p>0x080484e4 0x080485f8 0x00000003 0x00000001<br>
0x0804831d 0xbffff914 0x0000002f 0xbffff758 : <strong>sum의 stack frame</strong>  </p>

<blockquote>
<p>0x0804850b 0x00000001 0x00000002 0xbffff800<br>
0xb7e4942d 0xb7fc03c4 0xb7fff000 0x0804856b<br>
0x00000000 0x08048560 0x00000000 0x00000000 : <strong>main의 stack frame</strong></p>
</blockquote>
</blockquote>

<p><strong>Leave</strong> 실행 후에 <strong>func2의 stack frame</strong>이 모두 정리된 것 보이시나여?<br>
그리고 ebp가 sum의 ebp로 바뀌고,<br>
esp도 sum의 esp로 바뀌었습니다.</p>

<p>그리고 <strong>Ret</strong>을 만나면 <strong>0x080484e4로 리턴</strong>해 나머지 sum의 인스트럭션을 실행하고,<br>
끝으로 sum의 stack frame도 정리되고 나머지 main의 인스트럭션을 실행한 후<br>
프로그램을 종료하는 것이겠씀미다아아~</p>

<p>쟈아아아 오늘은 gdb도 써보거 스택에 대해서도 자세히 알아보았눈데,<br>
어떠셔쎄여?</p>

<p>다음 번엔 좀 더 다이나믹한 데이트를 합씨당.<br>
아 물론 데이트 코스는 제가 짭니당. ^ㅠ^
<br></p>

<p><em>다음 포스팅 예고</em></p>

<p><img src="../assets/Post_Images/2017/01/24/gdb_memory_day2/gdb-memory-day2-outro.gif" alt=""></p>

<p>그럼 이만 뿅!</p>

	  ]]></description>
	</item>

	<item>
	  <title>우리집에 GDB 있는데... 메모리 보고갈래? (1)</title>
	  <link>/umbrain//gdb-memory-day1</link>
	  <author>taBRis</author>
	  <pubDate>2017-01-22T06:41:00+00:00</pubDate>
	  <guid>/umbrain//gdb-memory-day1</guid>
	  <description><![CDATA[
	     <p><strong>출처 : <a href="https://bpsecblog.wordpress.com/2016/03/08/gdb_memory_1/">우리집에 GDB 있는데&hellip; 메모리 보고갈래? (1) - Hackerz on the Ship</a></strong></p>

<h2>들어가기에 앞서&hellip;</h2>

<blockquote>
<p>컴(존)알못들이여 오라.
보안 공부하다 높다란 진입장벽 앞에서 좌절하신 분들께 이 글을 바칩니다.
해커가 되겠다는 청운을 안고 대학을 입학했으나.. 4년 째 뉴비&hellip;★
컴알못인 제가 자세히 친절하게 하나하나 꼭꼭 씹어보겠습니다.</p>
</blockquote>

<hr>

<h2>Season 1. 우리집에 GDB있는데&hellip; 메모리 보고 갈래?</h2>

<p><br></p>

<h3>DAY #1. 듀근듀규뉸구누균ㄱ 첫만남</h3>

<p><br>
<img src="../assets/Post_Images/2017/01/22/gdb_memory_day1/gdb-memory-day1-intro.png" alt="*인트로*"></p>

<p>구체적으로 뭐하는지가 궁금하시다구여?
…뭘 하더라도 기초가 중요한 것 같네요.
메모리에 대한 썰부터 간단히 풀어볼게요!!
<br></p>

<p><img src="../assets/Post_Images/2017/01/22/gdb_memory_day1/gdb-memory-day1-1.png" alt="">
<em>[그림 1] 썰 주제 되십니다<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></em>
<br></p>

<hr>

<h4>1. 주소는 왜 때문에 0000 0000 ~ FFFF FFFF ???</h4>

<p>램은 몇 기가 쓰세여?<br>
제 노트북은 4GB의 램을 쓰고 있네요.</p>

<p><img src="../assets/Post_Images/2017/01/22/gdb_memory_day1/gdb-memory-day1-2.png" alt="">
<em>[그림 2] 이런거 은근 헷갈리지 않음요?</em>
<br></p>

<p>위의 계산에 의하면 4GB는 2<sup>32</sup> byte 사이즈의 메모리죠.</p>

<p>1Byte는 주소공간 한 개의 크기입니다<br>
즉, 4GB는 2<sup>32</sup> 개의 주소를 가질 수 있어요</p>

<p>그리고 1bit는 0 또는 1의 값만 가질 수 있기 때문에 32bit는 2<sup>32</sup> 만큼의 숫자를 표현할 수 있어요</p>

<p>32bit라는 것은 2<sup>32</sup> 개의 주소를 가지고 있다라는 뜻으로 이해하시면 됩니다!</p>

<p>그런데 우리가 메모리를 뭐로 접근합니까? 주소로 접근 하죠.<br>
32bit 운영체제는 수 표현을 최대 2<sup>32</sup> 까지 밖에 못 하기 때문에, 8GB나 16GB의 램을 가지고 있다고 하더라도 접근을 할 수가 없어요.</p>

<p>0000…0000(32개) 부터 1111….1111(32개) 까지를 보기 편하게 16진수로 변환하면?</p>

<p>00000000 ~ FFFFFFFF !</p>

<hr>

<h4>2. 유저 영역, 커널 영역은 왜 나뉘어져 있나</h4>

<p>시스템 운영에 필요한 메모리, 그리고 운영체제가 커널 영역에 올라가 있습니다.<br>
사용자가 운영체제가 올라가 있는 커널 영역에 마음대로 접근할 수 있다면…? 시스템이 안정적으로 운용될 수 없을거예여.</p>

<p>그렇기 때문에 사용자가 함부로 커널 영역에 접근할 수 없도록 메모리를 유저영역과 커널영역을 나누어 사용하는 겁니다.<br>
나누는 크기는 운영체제마다 다르고, 설정에 따라 영역의 크기를 조정할 수도 있어여.</p>

<hr>

<h4>3. 유저 영역의 메모리</h4>

<p>유저 메모리의 영역을 조금 더 자세히 살펴볼까요?</p>

<p><img src="../assets/Post_Images/2017/01/22/gdb_memory_day1/gdb-memory-day1-3.png" alt="">
<em>[그림 3] 안녕하새오 웬만한 기본서 펼치면 2n 페이지 쯤 있는 친구애오<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup></em>
<br></p>

<h5>3-1. 코드영역</h5>

<p>일단 메모리에 코드가 올라옵니다. 코드가 뭐냐구요?</p>

<p><img src="../assets/Post_Images/2017/01/22/gdb_memory_day1/gdb-memory-day1-4.png" alt="">
<em>[그림 3] 네 바로 이겁니다</em>
<br></p>

<p>이런거 어디서 많이 봤죠? c소스를 컴파일하면 어셈블리 코드로 번역(?)되잖아요.<br>
이 저급한 애들이 코드 영역에 올라 간다는 거져ㅎㅎ<br>
주소보면 32bit 시스템에서 익숙한 0804~로 시작함다. 메모리에 코드1가 올라갈 때 보통 저 영역에 올라갑니다.
<br></p>

<h5>3-2. 데이터영역</h5>

<p>그 다음은 데이터 영역입니다.<br>
전역변수가 이 영역에 로드되는데 항상 동일한 메모리에 위치하게 됩니당.</p>

<p>사용자가 입력하는 값이 전역변수로 정의되어있다고 가정해봅시다.<br>
고정된 메모리 주소 그리고 그 주소에 원하는 값을 쓸 수 있다면? 익스플로잇에 활용될 가능성이 갱장히 높아지겠죠?</p>

<p>여기까지가 고정된 주소에 올라오는 영역입니다.
<br></p>

<h5>3-3. 힙영역</h5>

<p>힙 영역은 동적으로 메모리를 할당하여 사용하는 공간입니다.<br>
대표적인 메모리 할당 함수로는 malloc 이 있죠. malloc으로 필요한 공간을 할당하면 힙 영역을 쓰게 되는겁니다.<br>
쓰다가 필요 없어지면 해제 해주면 되죠.</p>

<p>이 말인 즉슨 내가 힙 영역에 어떤 값을 엄청 많이 뿌려놓고 free 해준 후<br>
다시 이 공간을 재사용한다면..? 후.. 뭔가 익스플로잇할 때 낭낭히 활용될 거 같죠?</p>

<p><em>후.. 방금 당신은 UAF를 배웠습니다.</em>
<br></p>

<h5>3-4. 스택영역</h5>

<p>마지막 두둥 (유저영역) 메모리의 가장 바닥부터 채워지는 스택이 있죠.<br>
스택은 거꾸로 자라는거 아시져?<br>
왜냐구요?<br>
스택이 끝도없이 위아래도 모르고 자라다가 커널 건드리면…. 주옥되잖아요…<br>
그래서 얘는 거꾸로 자라는 겁니다.<br>
스택영역은 함수인자나 지역변수들이 올라옵니다.<br>
보통 스택 주소보면 0xbfff 이런식이예요.  </p>

<p>힙과 스택은 고정된 메모리에 올라오는 것이 아니기 때문에, 이 영역을 활용해 한번에 깔끔하게 쉘 따기란 넘나 어려운 것…</p>

<p>다음 포스팅엔 gdb 활용법으로 찾아오도록 할게여.<br>
메모리 구조를 gdb를 통해 뜯어보는 시간도 가져보도록 하겠슴다. 그럼 뿅★</p>

<p><em>written by in09</em></p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>[그림 1]: Pictogram(crown) created by Paul Verhulst from Noun Project&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>[그림 3]: Pictogram(book) created by Jakub Caja from Noun Project&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

	  ]]></description>
	</item>

	<item>
	  <title>초보자를 위한 시스템해킹 공부 가이드라인</title>
	  <link>/umbrain//System_Hacking_Study_Guide_for_Beginner</link>
	  <author>taBRis</author>
	  <pubDate>2017-01-21T02:17:00+00:00</pubDate>
	  <guid>/umbrain//System_Hacking_Study_Guide_for_Beginner</guid>
	  <description><![CDATA[
	     <p><strong>출처 : 초보자를 위한 시스템 해킹 공부 가이드라인 - <a href="https://www.facebook.com/HSPantom">홍승표 作</a>(a.k.a Phantom)</strong></p>

<h2>1. 기본기</h2>

<ul>
<li><mark>C언어</mark>, 객체 지향언어(C++, JAVA, Python etc&hellip;)중 하나 (개념이라도)</li>
<li><mark>리눅스</mark></li>
<li><p><mark>네트워크 기초</mark> (네트워크의 개념, 각 패킷의 형태, OSI 7 Layer, 라우터, 스위치 정도만이라도)</p></li>
<li><p><strong>TechTree 1</strong>
<img src="../assets/Post_Images/2017/01/21/System_Hacking_Study_Guide_for_beginner/tech.png" alt="TechTree 1">
<br></p></li>
<li><p><strong>TechTree 2</strong>
<img src="../assets/Post_Images/2017/01/21/System_Hacking_Study_Guide_for_beginner/tech2.png" alt="TechTree 2"></p></li>
</ul>

<hr>

<h2>2. 전문분야</h2>

<p><strong>1. Pwnable</strong><br>
<strong>2. Reversing</strong>
<br></p>

<h3>2.1. Pwnable</h3>

<ul>
<li><strong>추천 공부 순서</strong><br>
<strong>1. <mark>달고나 문서</mark></strong><br>
<strong>2. <mark>Hackerz on the ship</mark> - 우리 집에 gdb있는데.. 메모리 보고갈래?</strong><br>
<strong>3. <mark>HackerSchool</mark><sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>  FTZ traing 1~10, Level 1~20</strong><br>
<strong>4. HackerSchool Load of BOF 1~20</strong><br>
<strong>5. HackerSchool FC3</strong></li>
<li>처음에는 <mark>달고나 문서</mark>와 <mark>Hackerz on the ship의 문서</mark>를 읽는 것을 추천<strong><sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup></strong>. 리버싱도 마찬가지.</li>
<li><strong>여기까지 하는데도 상당한 시간이 걸린다.</strong></li>
<li>Training 1~10, Level 1~9까지는 처음에 왜 하는지 잘 이해가 가지 않을 수 있으나, 한번하고 나중에 다시보게 된다면 왜 이것을 했는지 이해할 수 있으며, 공부하면서 프로그래밍 등 기초가 흔들리는 자신의 모습을 볼 수 있을것.</li>
</ul>

<blockquote>
<p><strong>Phantom의 의견</strong></p>

<p>처음 공부할 때 어떻게 해야 할 지 몰라서 &lsquo;문제 풀이로 배우는 시스템 해킹 테크닉&#39;이라는 FTZ문제 풀이 책을 봤다. 이해가 가는 부분도 있고, 가지 않는 부분도 있을 것이다. 적어도 한번정도는 이해가 안가는 부분을 최대한 해보고, <mark>그래도 안되면 다음을 기약하며 넘기고</mark> 앞으로 계속 가기를 바란다.</p>

<p>FTZ를 풀고 LOB까지? FC3까지는 처음 혼자 해보다 <mark>잘 안되면 풀이를 보고 공부했다. 그리고 다시 풀이를 보지 않고 공부를 했다.</mark></p>

<p>해커스쿨의 각종 문서들과 발표자료 등 필요할 때 매우 자주 찾아보는 것을 추천한다.</p>

<p>그리고 문제풀이 라는 것은 FTZ Level9?부터 익스플로잇 코드까지 작성하는 것을 푸는 것이라 생각하는 것이 좋다.</p>
</blockquote>

<p><br></p>

<ul>
<li><strong>이후 추천 공부 순서</strong><br>
<strong>1. exploit-exercises.com - Nebula, Protostar, Fusion</strong><br>
<strong>2. OvertheWire - votex</strong><br>
<strong>3. Pwnable.kr</strong></li>
<li>이미 여기까지 할 수 있는 실력이라면 해킹방어대회(CTF)에 참가하면 순위권 안에 들지도 모른다.</li>
<li>Phantom이 공부한 책으로는 시스템 해킹 테크닉(FTZ), 해킹 공격의 예술이 Pwnable에는 해당되는 것 같다.</li>
<li>대부분이 문서로 존재한다.</li>
</ul>

<hr>

<h3>2.2 Reversing</h3>

<ul>
<li><strong>추천 공부 순서</strong><br>
<strong>1. Abex&rsquo;s Crackme 1~5</strong><br>
<strong>2. CodeEngn Basic RCE 1~20</strong><br>
<strong>3. Simples.kr Season 1 Crack, Unpack, Season 2 Reverse</strong><br>
<strong>4. CodeEngn Advanced RCE 1~18</strong><br>
<strong>5. Reversing.kr</strong><br></li>
</ul>

<blockquote>
<p><strong>Phantom의 의견</strong></p>

<p>처음 Reversing을 공부했을 때, 흔히 나뭇잎책, 방독면책 하는 바이블이라 불리는 책을 보면서 공부를 하는데, <u>하나도 몰랐다!!!</u></p>

<p>책을 따라가며 부분부분 이해하며 넘기긴 하는데, 정신을 차리면 영혼이 잠시 마실 나갔다 온 것처럼 기억을 못했고, 어셈블리어 한 줄 한 줄은 알겠는데, 전체적인 흐름이 보이지 않았다.</p>

<p>이런 이유로 리버싱을 자주 포기했었고, 거의 포기했다. <mark>역시 달고나 문서와 Hackerz on the ship의 문서를 읽길 바란다.</mark></p>

<p>멘토님이 한가지 과제를 주셨는데, Simples.kr Crackme 1~20 1번 Writeup 보고 풀고 1주일 후에 보고서 제출이었다. 진짜 더럽게 이해 안가고 그랬지만 1주일 안에 했다. 그리고 지금, 다시 문제를 푸니 전체적인 개념이 조금이나마 깃들어 있어 혼자 풀기 시작한다. 심지어 아주 쉬운 CTF문제 하나도 혼자 풀었다.</p>

<p>공부한 책으로는 나뭇잎, 방독면 등등 두 세 개 있는 것 같은데 대부분 레퍼런스로 보고 있다.</p>

<p>어셈블리어를 체화 하는 것에는 <mark>핸드레이</mark>(Hand+hex-ray)<strong><sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup></strong>가 좋다. C를 어셈으로, 어셈을 C로 풀어보는 것으로, 이것은 개인적인 의견이 아니라 대표님들이, 악성코드 분석 현업에 계신 분들이 말씀해 주신 것을 토대로 하는 이야기다.</p>

<p>이정도 할 생각이면 Pwnable이든, Reversing이든 크게 심적으로 힘들지 않을 것이다.</p>

<p>그리고 나뭇잎과 같은 책들은 처음엔 많이 어려울 수 있다. 하지만 선행학습이 된다면 그 내용들이 쉬워질 것이다. 나 또한 지금에서야 깨달은 것이지만 매우 쉽다. 아직 앞부분만이지만.</p>

<p>그 이후 PE부분부터는 OS지식에 대한 것이 부족하다는 것을 느낄 것이다. 그 때 부터 기본을 쌓기 시작할 수도 있다.</p>

<p>Crackme를 풀 때부터 Windows API를 보고 그럴 것이다. 그러면서 기초가 쌓인다. Codeengn은 시스템의 해커스쿨과 비슷한 곳이다. 그곳에서 문서를 쉽게 찾을 수 있을 것이다.</p>
</blockquote>

<hr>

<h2>3. 마무리</h2>

<p>Pwnable이든 Reversing이든 어느 정도의 기초지식은 Wargame을 통해 Writeup을 보고 먼저 한바퀴 만큼은 풀길 바란다. 그 이유는 적어도 이것이 어떤 것이라는 <u>적응</u>이 필요하기 때문이다. (특히 Reversing) 그리고 다시 돌아와서 제대로 공부하기를 바라며, 처음에 영혼없이 하더라도 이것이 어떤 것인지는 인식을 하고 있어야 한다.</p>

<p>공부하는 방법을 알아내는 것도 실력이고, 뭘 공부해야할지 알아내는 것도 실력이며, 뭘 공부할지 모를 때 오는 슬럼프를 극복하는 것도 실력이다.</p>

<p>어차피 공부하는 것은 혼자이다. 스터디에 들었다고, 팀에 들었다고 절대 내 실력이 오르는 것이 아니다. 이 생각이 제일 위험하고 자만하면 안된다.</p>

<p><strong>스스로 찾고 해결해 나가는 것이 중요하다.</strong></p>

<hr>

<h2>#1. 공부에 도움이 되는 사이트들</h2>

<table><thead>
<tr>
<th>분류</th>
<th>관련 사이트</th>
<th>비고</th>
</tr>
</thead><tbody>
<tr>
<td>침해사고 대응</td>
<td><a href="http://securitypractice.or.kr/index.php">http://securitypractice.or.kr/index.php</a></td>
<td>KISA에서 운영하는 침해사고 대응 훈련장</td>
</tr>
<tr>
<td>모의해킹</td>
<td><a href="http://hackerschool.org">http://hackerschool.org</a></td>
<td>시스템 해킹 실습 환경 제공 및 기타 정보들</td>
</tr>
<tr>
<td></td>
<td><a href="http://www.wechall.net">http://www.wechall.net</a></td>
<td>전세계 해킹 실습환경을 한곳에 모아둔 사이트</td>
</tr>
<tr>
<td></td>
<td><a href="http://webhacking.kr">http://webhacking.kr</a></td>
<td>웹 해킹 문제 풀이 사이트</td>
</tr>
<tr>
<td></td>
<td><a href="http://codeengn.com">http://codeengn.com</a></td>
<td>해킹관련 문서가 다량 보유된 사이트</td>
</tr>
<tr>
<td></td>
<td><a href="http://xcz.kr/START/challenge.php">http://xcz.kr/START/challenge.php</a></td>
<td>다양한 분야의 문제가 혼용된 사이트</td>
</tr>
<tr>
<td></td>
<td><a href="https://www.corelan.be/index.php/articles/">https://www.corelan.be/index.php/articles/</a></td>
<td>리버싱 등에 관한 상세한 기사들이 다수 존재하는 곳(영문)</td>
</tr>
<tr>
<td></td>
<td><a href="http://www.droidsec.org/wiki/#whitepapers">http://www.droidsec.org/wiki/#whitepapers</a></td>
<td>안드로이드 해킹에 대한 모든 정보가 있는 곳</td>
</tr>
<tr>
<td></td>
<td><a href="https://www.ietf.org/rfc.html">https://www.ietf.org/rfc.html</a></td>
<td>네트워크 프로토콜 RFC 자료</td>
</tr>
<tr>
<td></td>
<td><a href="http://www.owasp.net">http://www.owasp.net</a></td>
<td>OWASP, ESAPI등 관련 정보가 있는 곳</td>
</tr>
<tr>
<td></td>
<td><a href="http://resources.infosecinstitute.com">http://resources.infosecinstitute.com</a></td>
<td>아주 쉬운 기술 자료들이 모여있는 곳. 샘플도 제공(영문)</td>
</tr>
<tr>
<td></td>
<td><a href="http://www.wowhacker.com">http://www.wowhacker.com</a></td>
<td>언더해커 모임</td>
</tr>
<tr>
<td>프로그래밍</td>
<td><a href="http://www.pythonchallenge.com">http://www.pythonchallenge.com</a></td>
<td>Python 문제 풀이 사이트</td>
</tr>
<tr>
<td>포렌식</td>
<td><a href="http://maj3sty.tistory.com">http://maj3sty.tistory.com</a></td>
<td>개인이 운영하는 블로그로 포렌식 관련 자료 다수 보유</td>
</tr>
<tr>
<td></td>
<td><a href="http://forensic-proof.com">http://forensic-proof.com</a></td>
<td>플레인비트 김진국 대표가 운영하는 블로그</td>
</tr>
</tbody></table>

<hr>

<h2>#2. Reference to</h2>

<ul>
<li>보안 전문가의 길 (<a href="http://www.slideshare.net/seokhunhwnag/2015-v09">http://www.slideshare.net/seokhunhwnag/2015-v09</a>)</li>
<li>시스템 보안이란? (<a href="https://www.facebook.com/groups/438543032874514/1074936635901814/">https://www.facebook.com/groups/438543032874514/1074936635901814/</a>)</li>
<li>달고나 문서 (<a href="http://www.hackerschool.org/HS_Boards/data/Lib_system/buffer_overflow_foundation_pub.pdf">http://www.hackerschool.org/HS_Boards/data/Lib_system/buffer_overflow_foundation_pub.pdf</a>)</li>
<li>우리집에 gdb있는데.. 메모리 보고 갈래? (<a href="https://bpsecblog.wordpress.com/2016/03/08/%EC%9A%B0%EB%A6%AC%EC%A7%91%EC%97%90-gdb-%EC%9E%88%EB%8A%94%EB%8D%B0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%EA%B3%A0%EA%B0%88%EB%9E%98-1/">https://bpsecblog.wordpress.com/2016/03/08/%EC%9A%B0%EB%A6%AC%EC%A7%91%EC%97%90-gdb-%EC%9E%88%EB%8A%94%EB%8D%B0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%EA%B3%A0%EA%B0%88%EB%9E%98-1/</a>)</li>
<li>해킹 입문서, 커리큘럼, 테크트리, 리버싱 (<a href="http://blog.naver.com/93immm/130179760409">http://blog.naver.com/93immm/130179760409</a>)</li>
<li>Phantom이 쓴 Writeup (<a href="http://pantom.tistory.com">http://pantom.tistory.com</a>)</li>
</ul>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Wargame이라고 하며, 가상 OS에 취약점이 있는 환경을 만들어 각 단계에서 취약점을 공략하여 다음 단계로 올라가는 방식.  &nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>적어도 어떻게 돌아가는 것인지는 알아야 Reversing이든 Pwnable이든 가능하기 때문.  &nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>Hax-ray를 손으로 하는 방법.&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

	  ]]></description>
	</item>

	<item>
	  <title>참고 URL 스크랩</title>
	  <link>/umbrain//Facebook_scrap-20160308</link>
	  <author>taBRis</author>
	  <pubDate>2016-03-08T11:00:00+00:00</pubDate>
	  <guid>/umbrain//Facebook_scrap-20160308</guid>
	  <description><![CDATA[
	     <p><strong># MSF를 활용한 안드로이드 apk파일 백도어 제작 설명</strong>
<strong>출처 : <a href="https://techkernel.wordpress.com/2015/12/19/embed-metasploit-payload-in-apk-manually/">https://techkernel.wordpress.com/2015/12/19/embed-metasploit-payload-in-apk-manually</a></strong></p>

<blockquote>
<p>Embed a Metasploit Payload in an original .apk File | Part 2 – Do it manually</p>
</blockquote>

<hr>

<p><strong># MSSQL 환경에서 지속적인 공격을 위해 프로시저와 파워쉘을 활용한 사례</strong>
<strong>출처 : <a href="https://blog.netspi.com/sql-server-persistence-part-1-startup-stored-procedures/">https://blog.netspi.com/sql-server-persistence-part-1-startup-stored-procedures/</a></strong></p>

<blockquote>
<p>Maintaining Persistence via SQL Server – Part 1: Startup Stored Procedures</p>
</blockquote>

<hr>

<p><strong># IoT 보안 위키 페이지</strong>
<strong>출처 : <a href="https://iotsecuritywiki.com/">https://iotsecuritywiki.com</a></strong></p>

<blockquote>
<p>외국 동영상 강의 및 자료들 링크가 잘 되어있음</p>
</blockquote>

<hr>

<p><strong># Climber</strong>
<strong>출처 : <a href="http://www.kitploit.com/2016/03/climber-check-unixlinux-systems-for.html?utm_source=dlvr.it&amp;utm_medium=facebook/">http://www.kitploit.com/2016/03/climber-check-unixlinux-systems-for.html?utm_source=dlvr.it&amp;utm_medium=facebook</a></strong></p>

<blockquote>
<p>Climber - Check UNIX/Linux Systems For Privilege Escalation</p>
</blockquote>

<hr>

<p><strong># Blackpearl Security Blog</strong>
<strong>출처 : <a href="https://bpsecblog.wordpress.com/">https://bpsecblog.wordpress.com/</a></strong></p>

<blockquote>
<p>Hackerz on the Ship - Blackpearl Security Blog</p>
</blockquote>

<hr>

<p><strong># 2015년 주요 데이터 침해사고 조사 종합 보고서</strong>
<strong>출처 : <a href="http://www.verizonenterprise.com/DBIR/2015/">http://www.verizonenterprise.com/DBIR/2015/</a></strong></p>

<blockquote>
<p><a href="http://http://www.verizonenterprise.com/resources/reports/rp_data-breach-investigation-report-2015_en_xg.pdf">http://www.verizonenterprise.com/resources/reports/rp_data-breach-investigation-report-2015_en_xg.pdf</a></p>
</blockquote>

<hr>

<p><strong># CodeonWeb :: TensorFlow 강좌</strong>
<strong>출처 : <a href="https://codeonweb.com/%E2%80%A6/7e8c4944-308e-410e-85aa-644624613741">https://codeonweb.com/…/7e8c4944-308e-410e-85aa-644624613741</a></strong></p>

<blockquote>
<p>코드온웹에서 구글의 기계학습 프로그램인 TensorFlow를 이용하여, 기계 학습 및 딥 러닝을 간단히 배워볼 수 있는 코스를 준비했습니다. 웹에서 한국어 튜토리얼와 함께 바로 실습을 해 볼 수 있는 환경을 제공합니다.</p>
</blockquote>

<hr>

<p><strong># Python for Informatics: Exploring Information 직강</strong>
<strong>출처 : <a href="https://www.coursera.org/specializations/python">https://www.coursera.org/specializations/python</a></strong></p>

<blockquote>
<p>책읽는 대신에 듣는코스가 있는데, 초보자분들이 들으시면 좋을듯 해서 아직 모르시는 분들을 위해서 소개합니다. </p>

<p>Python for Informatics: Exploring Information 이라는 책의 저자 (Charles Severance, 미시건대 교수) 직강입니다. 프로그래밍을 전혀 모르는 사람들부터 들을 수 있도록 커리큘럼이 짜여져 있고, Specialization 코스이긴 한데, 공짜로 들을 수 있습니다. 책의 챕터를 나눠서 5-course series로 만들었고요. 아마 마지막 프로젝트코스인 Capstone코스는 그동안 돈안내셨으면 못들으실거에요. </p>

<p>이 코스가 좀 재미난 이유는 교수님이 포인트만 집어서 강의를 하기도 하고요. 학생들을 cheer-up시키기 위해 작은 퍼포먼스를 하기도 하고, 유명한 사람들 (파이썬창시자, jQuery창시자등)이나 외국에서 코스듣는 학생들과 직접 인터뷰해서 코스 중간중간에 끼워 넣기도 하고요. 그런 부분 보시는 재미도 쏠쏠할듯 하네요.</p>

<p>영어가 그리 어렵진 않지만, 그래도 혹 걱정되시면 비디오강의 보실때 캡션켜두시면 조금 도움이 될듯요. (단, 캡션이 100%정확하지 않다는건 염두에 두시고..)</p>
</blockquote>

<hr>

	  ]]></description>
	</item>

	<item>
	  <title>깃허브 인기 오픈소스 보안 툴 11선</title>
	  <link>/umbrain//security-git_open_source</link>
	  <author>taBRis</author>
	  <pubDate>2016-02-25T14:49:47+00:00</pubDate>
	  <guid>/umbrain//security-git_open_source</guid>
	  <description><![CDATA[
	     <p><strong>개발자/보안/오픈소스 :: InfoWorld</strong>
<strong>출처 : <a href="http://www.itworld.co.kr/print/89483">http://www.itworld.co.kr/print/89483</a></strong></p>

<blockquote>
<p>잡지 못할 버그는 없다”는 신념은 오픈소스 개발의 초석이다. 리누스의 법칙이라고 알려진 이 격언은 오픈소스 모델에서 보안 문제가 발생했을 때  IT 전문가들이 가장 먼저 떠올리는 말이기도 하다.</p>

<p>현재 깃허브 같은 인기 있는 코드 공유 사이트들 덕분에 오픈소스 커뮤니티는 악성코드를 분석하고 침입 테스트와 컴퓨터 포렌직을 수행하는 데 필요한 풍부한 보안 툴과 프레임워크를 제공하고 있어 다른 기업과 조직이 오픈소스 코드와 시스템을 안전하게 만드는 데 큰 도움을 주고 있다.</p>

<p>깃허브에서 인기를 얻고 있는 11가지의 필수 보안 프로젝트를 소개한다.<br>
더욱 안전한 코드와 시스템에 관심이 있는 운영자들이라면 반드시 확인해 보기 바란다.<br>
<a href="mailto:editor@itworld.co.kr">editor@itworld.co.kr</a></p>
</blockquote>

<p><strong>1. 메타스플로잇 프레임워크(Metasploit Framework)</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/13901916/13310589/a61c44c0-dbca-11e5-9801-1bf1a9244323.png" alt="Metasploit Framework" title="Metasploit Framework"><br>
메타스플로잇 프레임워크 오픈소스 커뮤니티와 보안업체 래피드7(Rapid7)가 주도하는 메타스플로잇 프레임워크(Metasploit Framework)는 침투 테스트를 위한 취약점 공격 개발 및 전달 시스템이다. 메타스플로잇 프레임워크에는 악의적인 공격자보다 먼저 취약점을 찾아냄으로써 애플리케이션의 보안 현황을 파악하는데 도움을 주는 취약점 공격 라이브러리가 포함되어 있으며, 윈도우, 리눅스, 맥, 안드로이드, iOS 등 다른 플랫폼용 소프트웨어를 테스트하는 데도 사용할 수 있다. 래피드7 엔지니어링 관리자 토드 비어슬리는 “메타스플로잇은 보안 연구원들이 상당히 일반적인 형식으로 취약점을 나타낼 수 있는 방법”이라며, “일반적인 컴퓨터, 전화기, 라우터, 스위치, 산업 제어 시스템, 임베디드 기기 등 모든 종류의 기기를 대상으로 한 수천 가지의 모듈을 가지고 있다. 메타스플로잇을 활용할 수 없는 소프트웨어나 펌웨어는 없다고 생각한다”고 강조했다.   </p>

<hr>

<p><strong>2. 브레이크맨(Breakeman)</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/13901916/13310590/acfe819a-dbca-11e5-983a-f1979440d472.png" alt="Breakeman" title="브레이크맨(Breakeman)">
브레이크맨 루비 온 레일스(Ruby on Rails) 앱을 위한 취약점 스캐너인 브레이크맨(Breakeman)은 프로그램의 한 부분에서 다른 부분으로 값을 추적하는 데이터 플로우 분석 기능도 제공한다. 브레이크맨의 저자이자 운영자인 저스틴 콜린스에 의하면, 이 소프트웨어를 사용하기 위해 애플리케이션 전체 스택을 설치할 필요는 없다. 브레이크맨은 &lsquo;블랙 박스(black box)&rsquo; 스캐너들보다 빨라 대형 애플리케이션도 단 몇 분만에 검사할 수 있다고 주장한다. 브레이크맨을 사용할 때는 긍정 오류(False Positives)에 주의해야 한다. 물론, 최근 이런 문제점을 해결하기 위한 교정 코드가 개발된 상태이다. 또한 웹사이트 보안 스캐너와 함께 사용해야 한다. 콜린스는 다른 플랫폼까지 브레이크맨을 확장시킬 계획은 없지만, 개발자들이 이 코드를 참고하는 것은 적극 장려한다는 입장이다. </p>

<hr>

<p><strong>3. 쿠쿠 샌드박스(Cuckoo Sandbox)</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/13901916/13310625/15fde64a-dbcb-11e5-89e4-b4c2ec2724bc.png" alt="쿠쿠 샌드박스(Cuckoo Sandbox)" title="쿠쿠 샌드박스(Cuckoo Sandbox)">
쿠쿠 샌드박스(Cuckoo Sandbox)는 자동화된 동적 악성코드 분석 시스템으로, 격리된 환경에서 의심스러운 파일을 검사하는데 사용된다. 쿠쿠 샌드박스 프로젝트 설립자인 클라우디오 과니에리는 “주요 목적은 윈도우 가상머신을 시작할 때 자동적으로 실행되고 내부에서 어떤 악성코드의 행동이라도 모니터링하는 것이다. 실행이 완료되면 쿠쿠는 수집된 데이터를 심층 분석하고 어떤 악성코드인지를 설명하는 통합 보고서를 만든다”고 설명했다. 분석을 통해 네이티브 함수와 윈도우 API 호출 추적, 생성되고 삭제된 파일의 사본, 분석 기기의 메모리 덤프 등의 데이터를 생성한다. 처리와 보고 방식은 맞춤형으로 설정할 수 있고, 결과 보고서는 JSON과 HTML 등의 다양한 포맷으로 생성할 수 있다. </p>

<hr>

<p><strong>4. 몰로치(Moloch)</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/13901916/13310627/20666828-dbcb-11e5-834e-99d4a49b6dcb.png" alt="몰로치(Moloch)" title="몰로치(Moloch)">
몰로치(Moloch)는 확장 가능한 IPv4 패킷 캡처 및 인덱싱, 데이터베이스 시스템으로, 데이터를 살펴보고 검색하고 외부로 내보내는 단순한 웹 인터페이스가 특징이다. HTTPS나 HTTP 약식 암호를 사용해 적용할 수 있으며, IDS 엔진을 대신하는 역할을 하지는 않는다. 몰로치는 모든 네트워크 트래픽을 표준 PCAP 형식으로 저장하고 인덱싱하며, 여러 시스템에 걸쳐서 배치할 수 있으며, 기가비트급 트래픽용으로 확장할 수도 있다. 캡처와 뷰어, 일래스틱서치(Elasticsearch)의 세 가지 요소로 구성되어 있다. 캡처는 단일 쓰레드의 C 애플리케이션으로 시스템 당 여러 개의 캡처 프로세스를 실행할 수 있으며, 뷰어는 Node.js 애플리케이션으로 웹 인터페이스와 PCAP 파일 전송을 담당한다. </p>

<hr>

<p><strong>5. 모즈데프(MozDef)</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/13901916/13310634/31cc0b72-dbcb-11e5-9f33-da1e7af6fb52.png" alt="모즈데프(MozDef)" title="모즈데프(MozDef)">
모질라 디펜스 플랫폼 ‘모즈데프(MozDef)’라는 이름으로 불리는 모질라 디펜스 플랫폼(Mozilla Defense Platform)은 보안 상황 처리 프로세스를 자동화해 공격자 정보를 확보할 수 있도록 한다. 프로젝트 저자 제프 브리너는 실시간 통합 플랫폼으로 모니터링과 대응, 협업을 진행하고 역량을 강화할 수 있다고 설명한다. 모즈데프는 전통적인 SIEM(Security Information and Event Management) 기능을 협업화된 상황 대응, 시각화, 다른 시스템으로의 손쉬운 통합으로 확장시켜 준다. 모즈데프는 일래스틱서치, 메테오(Meteor), 몽고DB(MongoDB)를 활용해 다양한 데이터를 수집하고, 이를 저마다의 알맞은 방식으로 유지한다. 브리너는 “모즈데프를 보안 상황 대응 워크플로우를 보조하는 일래스틱서치 상위의 SIEM 오버레이로 볼 수도 있다”고 설명했다. 이 프로젝트는 2013년 모질라 내에서 개념 검증 단계로 시작됐다. </p>

<hr>

<p><strong>6. 마이다스(MIDAS)</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/13901916/13310647/54c54b7a-dbcb-11e5-9f40-d983e5928ef1.png" alt="마이다스(MIDAS)" title="마이다스(MIDAS)">
Etsy와 페이스북 보안팀 사이의 협업을 기반으로 하는 마이다스(MIDAS)는 맥 침투 감지와 분석 시스템 구축 프레임워크다. 이 모듈식 프레임워크는 OS X의 지속 메커니즘에 대한 수정을 감지하기 위한 예시 모듈과 보조 유틸리티를 제공한다. 이 프로젝트는 자가 방어 보안(Homebrew Defensive Security)와 공격 주도형 방어(Attack-Driven Defense) 프레젠테이션에서 나온 개념을 기반으로 삼고 있다. Etsy와 페이스북 보안팀은 소개 문서를 통해 “이 프레임워크 발표에 있어서 우리의 공통 목표는 이 분야에 대한 토론을 활성화하고 기업이나 기관에 일반적인 감염 패턴을 탐지할 수 있도록 OS X 엔드포인트 관리를 위한 시작점을 제공하는데 있다”고 밝혔다. MIDAS 사용자는 호스트 기반 점검이나 인증, 분석 등을 위한 모듈을 정의할 수 있다. </p>

<hr>

<p><strong>7. 브로(Bro)</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/13901916/13310650/59029b98-dbcb-11e5-9289-609010ee6aa4.png" alt="브로(Bro)" title="브로(Bro)">
미국 캘리포니아주립대 국제컴퓨터공학연구소의 선임 연구원이자 브로(Bro)의 선도 개발자인 로빈 소머는 네트워크 분석 프레임워크인 브로가 많은 사람들이 생각하는 침입 탐지 시스템과는 완전히 다른 것이라고 말한다. 침입 탐지 시스템이 일반적으로 공격 패턴과 연관되는 것과 달리, 브로는 사용자들이 아주 높은 수준의 시맨틱 단계로 작업을 프로그래밍할 수 있어서 보통의 시스템들보다 더욱 강력한 프로그래밍 언어라는 것. 브로는 공격을 찾고 상황 정보와 사용 패턴을 제공한다. 그리고 네트워크 트래픽에 대한 정보를 얻고 네트워크 패킷을 조합해 네트워크 상의 시스템에 대한 가시성을 제공한다. 좀 더 일반적인 트래픽 분석을 위한 플랫폼도 제공한다. </p>

<hr>

<p><strong>8. OS X 오디터(OS X Auditor)</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/13901916/13310654/5d960460-dbcb-11e5-8e7f-3b35c6f05fc5.png" alt="OS X 오디터(OS X Auditor)" title="OS X 오디터(OS X Auditor)">
OS X 오디터(OS X Auditor)는 무료 컴퓨터 포렌직 툴로 구동되는 시스템이나 시스템 사본 상에 있는 의도치 않은 부산물들을 세밀하게 분석한다. 대상이 되는 부산물은 커널 확장자나 시스템이나 서드파티의 에이전트와 데몬, 사용하지 않은 기동 아이템, 사용자가 다운로드한 파일, 설치된 에이전트 등이다. 사용자가 따로 저장한 파일도 감사 대상 시스템의 사파리 히스토리, 파이어폭스 쿠키, 크롬 히스토리, 소셜과 이메일 계정, 와이파이 AP 등을 기반으로 추출한다. </p>

<hr>

<p><strong>9. 슬루트 키트(Sleuth Kit)</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/13901916/13310662/61a08756-dbcb-11e5-9b7d-a6e548ee099f.png" alt="슬루트 키트(Sleuth Kit)" title="슬루트 키트(Sleuth Kit)">
슬루트 키트(Sleuth Kit)는 라이브러리와 볼륨과 파일 시스템 데이터를 포함한 디스크 이미지 조사를 위한 명령줄 툴 콜렉션을 갖추고 있다. 이 키트는 플러그인 프레임워크를 제공해 사용자가 예를 들어 파일 컨텐츠를 분석하고 자동화된 시스템을 구축하기 위한 모듈 등을 추가할 수 있게 해준다. 마이크로소프트와 유닉스 시스템에 맞춰져 있으며, 조사자가 보안 사고 대응 중이거나 가동 중인 시스템의 이미지로부터 증거를 식별 복구할 수 있게 해준다. 슬루스 키트와 다른 툴의 상위 사용자 인터페이스의 역할을 수행하는 것은 디지털 포렌직 플랫폼인 오톱시(Autopsy)다. 슬루스 키트와 오톱시의 저작자인 브라이언 캐리어는 “오톱시는 좀 더 사용자 지향적이고, 슬루스 키트는 직접 사용하기 보다는 자체 툴에 통합하는 라이브러리에 가깝다”라고 설명했다. </p>

<hr>

<p><strong>10. OSSEC</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/13901916/13310665/6789cd4e-dbcb-11e5-8548-8ec73f1c8acb.png" alt="OSSEC" title="OSSEC">
OSSEC 호스트 기반 침입 탐지 시스템은 로그 분석, 파일 무결성 점검, 정책 모니터링, 경보, 리눅스, 맥 OS, 솔라리스, AIX, 윈도우 등을 포함한 다양한 시스템에 대한 능동적인 대응을 수행한다. OSSEC는 PCI와 HIPAA를 포함한 컴플라이언스 충족에 도움을 주고 인증 받지 않은 파일 시스템 수정과 소프트웨어와 커스텀 앱의 로그파일에 내장된 강의적인 행위를 감지하면 경보를 보내도록 구성할 수 있다. 중앙집중화된 관리 서버는 여러 운영체제에 걸쳐 정책을 관리한다. OSSEC는 트렌드마이크로가 지원하고 있다. </p>

<hr>

<p><strong>11. 패시브DNS(PassiveDNS)</strong>
<img src="https://cloud.githubusercontent.com/assets/13901916/13310668/6c9e0c8c-dbcb-11e5-89bf-604f0958217b.png" alt="패시브DNS(PassiveDNS)" title="패시브DNS(PassiveDNS)"></p>

<p>패시브DNS(PassiveDNS)는 보안 사고 처리, 네트워크 보안 모니터링, 디지털 포렌직을 지원하기 위해 수동적인 방식으로 DNS 기록을 수집한다. 이 소프트웨어는 PCAP 파일을 읽고 DNS 데이터를 로그 파일이나 스니프 트래픽으로 출력하도록 설정할 수 있다. 이 툴은 IPv4와 IPv6 트래픽에서 사용할 수 있으며, TCP와 UDP 프로토콜을 통해 트래픽을 분석하고, 중복 DNS 데이터를 메모리 내에 임시저장해 데이터 로그의 양을 제한한다. </p>

	  ]]></description>
	</item>


</channel>
</rss>
